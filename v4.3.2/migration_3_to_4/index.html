<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Migration Guide (from v3 to v4) · GraphPPL.jl</title><meta name="title" content="Migration Guide (from v3 to v4) · GraphPPL.jl"/><meta property="og:title" content="Migration Guide (from v3 to v4) · GraphPPL.jl"/><meta property="twitter:title" content="Migration Guide (from v3 to v4) · GraphPPL.jl"/><meta name="description" content="Documentation for GraphPPL.jl."/><meta property="og:description" content="Documentation for GraphPPL.jl."/><meta property="twitter:description" content="Documentation for GraphPPL.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphPPL.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../syntax_guide/">Syntax Guide</a></li><li><a class="tocitem" href="../nested_models/">Nested Models</a></li><li><span class="tocitem">Plugins</span><ul><li><a class="tocitem" href="../plugins/overview/">Overview</a></li><li><a class="tocitem" href="../plugins/constraint_specification/">Variational Inference &amp; Constraints</a></li><li><a class="tocitem" href="../plugins/meta_specification/">Attaching metadata to nodes</a></li><li><a class="tocitem" href="../plugins/created_by/">Tracking creation of nodes</a></li><li><a class="tocitem" href="../plugins/node_id/">Setting ID of nodes</a></li></ul></li><li class="is-active"><a class="tocitem" href>Migration Guide (from v3 to v4)</a><ul class="internal"><li><a class="tocitem" href="#The-@model-macro"><span>The <code>@model</code> macro</span></a></li><li><a class="tocitem" href="#Model-definition"><span>Model definition</span></a></li><li><a class="tocitem" href="#Constraint-specification"><span>Constraint specification</span></a></li><li><a class="tocitem" href="#Meta-specification"><span>Meta specification</span></a></li><li><a class="tocitem" href="#Dispatch"><span>Dispatch</span></a></li><li><a class="tocitem" href="#Positional-arguments"><span>Positional arguments</span></a></li><li class="toplevel"><a class="tocitem" href="#Mixture-Nodes"><span>Mixture Nodes</span></a></li><li class="toplevel"><a class="tocitem" href="#Overview-of-the-removed-functionality"><span>Overview of the removed functionality</span></a></li></ul></li><li><a class="tocitem" href="../developers_guide/">Developers Guide</a></li><li><a class="tocitem" href="../custom_backend/">Custom backend</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Migration Guide (from v3 to v4)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Migration Guide (from v3 to v4)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/GraphPPL.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/GraphPPL.jl/blob/main/docs/src/migration_3_to_4.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Migration-Guide"><a class="docs-heading-anchor" href="#Migration-Guide">Migration Guide</a><a id="Migration-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Migration-Guide" title="Permalink"></a></h1><p>This page describes the major changes between GraphPPL <code>v3</code> and <code>v4</code>. The <code>v4</code> introduced many changes to the language and the API. The changes are designed to make the language more consistent and easier to use, but also are tested better and provides extra features for the future releases. These changes are, however, not backward compatible with the previous versions of GraphPPL, such as <code>v3</code>. In this guide, we will describe the major changes between the two versions and provide examples to help you migrate your code to the new version.</p><h2 id="The-@model-macro"><a class="docs-heading-anchor" href="#The-@model-macro">The <code>@model</code> macro</a><a id="The-@model-macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-@model-macro" title="Permalink"></a></h2><p>The <code>@model</code> macro is no longer exported from the library and is only provided for interactive purposes (e.g. plotting).  The downstream package must define their own <code>@model</code> macro and use the <a href="../custom_backend/#GraphPPL.model_macro_interior"><code>GraphPPL.model_macro_interior</code></a> function with a <a href="../custom_backend/#custom-backend">custom backend</a>.</p><h2 id="Model-definition"><a class="docs-heading-anchor" href="#Model-definition">Model definition</a><a id="Model-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Model-definition" title="Permalink"></a></h2><p>Model definition in version <code>4</code> is similar to version <code>3</code>. The main difference is the deletion of the <code>datavar</code>, <code>randomvar</code> and <code>constvar</code> syntax. Previously the random variables and data variables needed to be specified in advance. This is no longer possible but also is unnecessary. <code>GraphPPL</code> is able to infer the type of the variable based on the way in which it is used. This greatly trims down the amount of code to be written in the model definition.  </p><p>The following example is a simple model definition in version <code>3</code>:</p><pre><code class="language-julia hljs">@model function SSM(n, x0, A, B, Q, P) 
 	 x = randomvar(n) 
 	 y = datavar(Vector{Float64}, n) 
 	 x_prior ~ MvNormal(μ = mean(x0), Σ = cov(x0)) 
 	 x_prev = x_prior 
 	 for i in 1:n 
 		   x[i] ~ MvNormal(μ = A * x_prev, Σ = Q) 
 		   y[i] ~ MvNormal(μ = B * x[i], Σ = P) 
 		   x_prev = x[i] 
 	 end 
 end </code></pre><p>The equivalent model definition in version <code>4</code> is as follows:</p><pre><code class="language-julia hljs"> @model function SSM(y, prior_x, A, B, Q, P) 
     x_prev ~ prior_x
     for i in eachindex(y)
        x[i] ~ MvNormal(μ = A * x_prev, Σ = Q) 
        y[i] ~ MvNormal(μ = B * x[i], Σ = P) 
        x_prev = x[i]
    end
end</code></pre><p>As you can see, variable creation still requires the <code>~</code> operator. However, there are a couple of subtle changes compared to the old version of GraphPPL:</p><ul><li>The <code>randomvar</code> and <code>datavar</code> syntax is no longer needed. <code>GraphPPL</code> is able to infer the type of the variable based on the way in which it is used.</li><li>The data <code>y</code> is an explicit parameter of the model function.</li><li>The <code>n</code> parameter is no longer needed. The size of the variable <code>x</code> is inferred from the size of the variable <code>y</code>.</li><li>We are no longer required to extract the mean and covariance of our prior distribution using the <code>MvNormal(μ = mean(x0), Σ = cov(x0))</code> pattern. Instead, we can pass a prior and call <code>x_prev ~ prior_x</code> to assign it to an edge in the factor graph.</li><li>The data <code>y</code> is passed as an argument to the model. This is because of the support of nested models in version <code>4</code>. In the <a href="#nested-models">Nested models</a> we elaborate more on this design choice.</li></ul><h3 id="Vectors-and-arrays"><a class="docs-heading-anchor" href="#Vectors-and-arrays">Vectors and arrays</a><a id="Vectors-and-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Vectors-and-arrays" title="Permalink"></a></h3><p>As seen in the example above, we can assign <code>x[i]</code> without explicitly defining <code>x</code> first. <code>GraphPPL</code> is able to infer that <code>x</code> is a vector of random variables, and will grow the internal representation of <code>x</code> accordingly to accomodate <code>i</code> elements. Note that this works recursively, so <code>z[i, j]</code> will define a matrix of random variables. GraphPPL does check that the index <code>[i,j]</code> is compatible with the shape of the variable <code>z</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>eachindex(y)</code> works only if <code>y</code> has a static data associated with it. Read the documentation for <a href="../developers_guide/#GraphPPL.create_model"><code>GraphPPL.create_model</code></a> for more information.</p></div></div><h3 id="Factor-aliases"><a class="docs-heading-anchor" href="#Factor-aliases">Factor aliases</a><a id="Factor-aliases-1"></a><a class="docs-heading-anchor-permalink" href="#Factor-aliases" title="Permalink"></a></h3><p>In version <code>4</code>, we can define factor aliases to define different implementations of the same factor. For example, in <code>RxInfer.jl</code>, there are multiple implentations of the <code>Normal</code> distribution. Previously, we would have to explicitly call <code>NormalMeanVariance</code> or <code>NormalMeanPrecision</code>. In version <code>4</code>, we can define factor aliases to default to certain implementations when specific keyword arguments are used on construction. For example: <code>Normal(μ = 0, σ² = 1)</code> will default to <code>NormalMeanVariance</code> and <code>Normal(μ = 0, τ = 1)</code> will default to <code>NormalMeanPrecision</code>. This allows users to quickly toggle between different implementations of the same factor, while keeping an implementation agnostic model definition.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This feature works only in the combination with the <code>~</code> operator, which creates factor nodes. Therefore it cannot be used to instantiate a distribution object in a regular Julia code.</p></div></div><h3 id="Nested-models"><a class="docs-heading-anchor" href="#Nested-models">Nested models</a><a id="Nested-models-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-models" title="Permalink"></a></h3><p>The major difference between versions <code>3</code> and <code>4</code> is the support for nested models. In version <code>4</code>, models can be nested within each other. This allows for more complex models to be built in a modular way. The following example demonstrates how to nest models in version <code>4</code>:</p><pre><code class="language-julia hljs">@model function kalman_filter_step(y, prev_x, new_x, A, B, Q, P)
    new_x ~ MvNormal(μ = A * prev_x, Σ = Q)
    y ~ MvNormal(μ = B * new_x, Σ = P)
end

@model function state_space_model(y, A, B, Q, P)
    x[1] ~ MvNormal(zeros(2), diagm(ones(2)))
    for i in eachindex(y)
        y[i] ~ kalman_filter_step(prev_x = x[i], new_x = new(x[i + 1]), A=A, B=B, Q=Q, P=P)
    end
end</code></pre><p>Note that we reuse the <code>kalman_filter_step</code> model in the <code>state_space_model</code> model. In the argument list of any <code>GraphPPL</code> model, we have to specify the Markov Blanket of the model we are defining. This means that all interfaces with the outside world have to be passed as arguments to the model. For the <code>kalman_filter_step</code> model, we pass the previous state <code>prev_x</code>, the new state <code>new_x</code>, the observation <code>y</code> as well as the parameters <code>A</code>, <code>B</code>, <code>Q</code> and <code>P</code>. This means that, when invoking a submodel in a larger model, we can specify all components of the Markov Blanket. Note that, in the <code>state_space_model</code> model, we do not pass <code>y</code> as an argument to the <code>kalman_filter_step</code> model. <code>GraphPPL</code> will infer that <code>y</code> is missing from the argument list and assign it to whatever is left of the <code>~</code> operator. Note that we also use the <code>new(x[i + 1])</code> syntax to create a new variable in the position of <code>x[i + 1]</code>. Since <code>y</code> is also passed in the argument list of the <code>state_space_model</code> model, we could have written this line with the equivalen statement <code>x[i + 1] ~ kalman_filter_step(prev_x = x[i], y = y[i], A=A, B=B, Q=Q, P=P)</code>. However, to respect the generative direction of the model and to make the code more readable, we use the <code>new(x[i + 1])</code> syntax. Note, however, that the underlaying representation of the models in <code>GraphPPL</code> are still undirected.</p><h2 id="Constraint-specification"><a class="docs-heading-anchor" href="#Constraint-specification">Constraint specification</a><a id="Constraint-specification-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-specification" title="Permalink"></a></h2><p>With the introduction of nested models, the specification of variational constraints becomes more difficult. In version <code>3</code>, variable names were uniquely defined in the model, which made it easy to specify constraints on variables. In version <code>4</code>, nested models can contain variables with the same name as their parents, even though they are distinct random variables. Therefore, we need to specify constraints on submodel level in the constraints macro. This is done with the <code>for q in _submodel_</code> syntax. </p><p>For example:</p><pre><code class="language-julia hljs">@constraints begin
    for q in kalman_filter_step
        q(new_x, prev_x, y) = q(new_x, prev_x)q(y)
    end
end</code></pre><p>This specification reuses the same constraint to all instances of the <code>kalman_filter_step</code> submodel. Of course, we&#39;d like to have more flexibility in the constraints we can specify. Therefore, we can also specify constraints on a specific instance of the submodel. For example:</p><pre><code class="language-julia hljs">@constraints begin
    for q in (kalman_filter_step, 1)
        q(new_x, prev_x, y) = q(new_x, prev_x)q(y)
        q(new_x) :: Normal
    end
end</code></pre><p>This pushes the constraint to the first instance of the <code>kalman_filter_step</code> submodel. With this syntax, we can specify constraints on any instance of a submodel. </p><p>The function syntax for constraints is still supported. For example:</p><pre><code class="language-julia hljs">@constraints function ssm_constraints(factorize)
    for q in kalman_filter_step
        if factorize
            q(new_x, prev_x, y) = MeanField()
        else
            q(new_x, prev_x, y) = q(new_x, prev_x)q(y)
        end
    end
end</code></pre><h2 id="Meta-specification"><a class="docs-heading-anchor" href="#Meta-specification">Meta specification</a><a id="Meta-specification-1"></a><a class="docs-heading-anchor-permalink" href="#Meta-specification" title="Permalink"></a></h2><p>The meta specification follows exactly the same structure as the constraints specification. Nested models in the <code>@meta</code> macro are specified in the same way as in the <code>@constraints</code> macro. </p><p>For example:</p><pre><code class="language-julia hljs">@meta begin
    for meta in some_submodel
        GCV(x, k, w) -&gt; GCVMetadata(GaussHermiteCubature(20))
    end
    y -&gt; SomeMetaData()
end</code></pre><p>Additionally, we can pass arbitrary metadata to the inference backend. For example:</p><pre><code class="language-julia hljs">@meta begin
    GCV(x, k, w) -&gt; GCVMetadata(GaussHermiteCubature(20))
    x -&gt; (prod_constraint = SomeProdConstraint(), )
end</code></pre><p>By passing a <code>NamedTuple</code> in the <code>@model</code> macro, we can pass arbitrary metadata to the inference backend that we would previously have to specify in the <code>where</code> clause of a node. With the added functionality of the <code>@meta</code> macro, we can pass metadata to the inference backend in a more structured way, and detach metadata definition from model definition.</p><h2 id="Dispatch"><a class="docs-heading-anchor" href="#Dispatch">Dispatch</a><a id="Dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Dispatch" title="Permalink"></a></h2><p>In the new version of <code>GraphPPL.jl</code> it is no longer possible to use Julia&#39;s multiple dispatch within the <code>@model</code> function definition.  The workaround is to use nested models instead, e.g. users can pass submodels as an extra argument, therefore change the structure of the model based on the input arguments. </p><h2 id="Positional-arguments"><a class="docs-heading-anchor" href="#Positional-arguments">Positional arguments</a><a id="Positional-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Positional-arguments" title="Permalink"></a></h2><p>In the new version of <code>GraphPPL.jl</code> positional arguments within model construction is no longer supported and all arguments must be named explicitly. For example:</p><pre><code class="language-julia hljs">@model function beta_bernoulli(y, a, b)
    t ~ Beta(a, b)
    for i in eachindex(y)
        y[i] ~ Bernoulli(t)
    end
end</code></pre><pre><code class="language-julia hljs">model = beta_bernoulli(1.0, 2.0) # ambigous and unsupported</code></pre><pre><code class="language-julia hljs">model = beta_bernoulli(a = 1.0, b = 2.0) # explicitly defined via keyword arguments</code></pre><p>The same recipe applies when nesting models within each other, e.g.</p><pre><code class="language-julia hljs">@model function bigger_model(y)
    a ~ Uniform(0.0, 10.0)
    b ~ Uniform(0.0, 10.0)
    y ~ beta_bernoulli(a = a, b = b)
end</code></pre><h1 id="Mixture-Nodes"><a class="docs-heading-anchor" href="#Mixture-Nodes">Mixture Nodes</a><a id="Mixture-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Mixture-Nodes" title="Permalink"></a></h1><p>The interface of the mixture nodes does no longer require a tuple of inputs. Instead, the inputs can be passed as a vector as well. For example:</p><pre><code class="language-julia hljs">@model function mixture_model(y)
    # specify two models
    m_1 ~ Beta(2.0, 7.0)
    m_2 ~ Beta(7.0, 2.0)

    # specify prior on switch param
    s ~ Bernoulli(0.7) 

    # specify mixture prior Distribution
    θ ~ Mixture(switch = s, inputs = [m_1, m_2])
end</code></pre><h1 id="Overview-of-the-removed-functionality"><a class="docs-heading-anchor" href="#Overview-of-the-removed-functionality">Overview of the removed functionality</a><a id="Overview-of-the-removed-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-the-removed-functionality" title="Permalink"></a></h1><ul><li>The <code>datavar</code>, <code>randomvar</code> and <code>constvar</code> syntax is removed. <code>GraphPPL</code> is able to infer the type of the variable based on the way in which it is used.</li><li>Specifying factorization constraints in the <code>where</code> clause of a node is no longer possible. The <code>where</code> syntax can still be used to specify metadata for factor nodes, but factorization constraints can only be specified with the <code>@constraints</code> macro.</li><li>Dispatch in the <code>@model</code> macro is not supported.</li><li>Positional arguments in the <code>@model</code> macro are not supporeted.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plugins/node_id/">« Setting ID of nodes</a><a class="docs-footer-nextpage" href="../developers_guide/">Developers Guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 17 July 2024 10:06">Wednesday 17 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

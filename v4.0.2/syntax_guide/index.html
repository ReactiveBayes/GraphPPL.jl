<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Syntax Guide · GraphPPL.jl</title><meta name="title" content="Syntax Guide · GraphPPL.jl"/><meta property="og:title" content="Syntax Guide · GraphPPL.jl"/><meta property="twitter:title" content="Syntax Guide · GraphPPL.jl"/><meta name="description" content="Documentation for GraphPPL.jl."/><meta property="og:description" content="Documentation for GraphPPL.jl."/><meta property="twitter:description" content="Documentation for GraphPPL.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphPPL.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Syntax Guide</a><ul class="internal"><li><a class="tocitem" href="#The-@model-macro"><span>The <code>@model</code> macro</span></a></li><li><a class="tocitem" href="#The-operator"><span>The <code>~</code> operator</span></a></li><li><a class="tocitem" href="#The-:-operator"><span>The <code>:=</code> operator</span></a></li><li><a class="tocitem" href="#Broadcasting-with-the-operator"><span>Broadcasting with the <code>~</code> operator</span></a></li><li><a class="tocitem" href="#Difference-between-random-variables-and-parameters"><span>Difference between random variables and parameters</span></a></li><li><a class="tocitem" href="#local-keyword"><span><code>local</code> keyword</span></a></li><li><a class="tocitem" href="#The-new-function"><span>The <code>new</code> function</span></a></li><li><a class="tocitem" href="#The-where-{-meta-...-}-block"><span>The <code>where { meta = ... }</code> block</span></a></li><li><a class="tocitem" href="#Tracking-the-created_by-field"><span>Tracking the <code>created_by</code> field</span></a></li><li><a class="tocitem" href="#The-return-statement"><span>The <code>return</code> statement</span></a></li><li><a class="tocitem" href="#Nested-models"><span>Nested models</span></a></li><li><a class="tocitem" href="#Scopes"><span>Scopes</span></a></li><li><a class="tocitem" href="#Arrays-in-GraphPPL"><span>Arrays in GraphPPL</span></a></li></ul></li><li><a class="tocitem" href="../nested_models/">Nested Models</a></li><li><span class="tocitem">Plugins</span><ul><li><a class="tocitem" href="../plugins/overview/">Overview</a></li><li><a class="tocitem" href="../plugins/constraint_specification/">Variational Inference &amp; Constraints</a></li><li><a class="tocitem" href="../plugins/meta_specification/">Attaching metadata to nodes</a></li><li><a class="tocitem" href="../plugins/created_by/">Tracking creation of nodes</a></li><li><a class="tocitem" href="../plugins/node_id/">Setting ID of nodes</a></li></ul></li><li><a class="tocitem" href="../migration_3_to_4/">Migration Guide (from v3 to v4)</a></li><li><a class="tocitem" href="../developers_guide/">Developers Guide</a></li><li><a class="tocitem" href="../custom_backend/">Custom backend</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Syntax Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Syntax Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/GraphPPL.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/GraphPPL.jl/blob/main/docs/src/syntax_guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="syntax-guide"><a class="docs-heading-anchor" href="#syntax-guide">Syntax Guide</a><a id="syntax-guide-1"></a><a class="docs-heading-anchor-permalink" href="#syntax-guide" title="Permalink"></a></h1><h2 id="The-@model-macro"><a class="docs-heading-anchor" href="#The-@model-macro">The <code>@model</code> macro</a><a id="The-@model-macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-@model-macro" title="Permalink"></a></h2><p>The <code>@model</code> macro accepts a description of a probabilistic program and defines a function that creates (upon materialization) a corresponding factor graph. The single argument of the macro is a Julia function. </p><pre><code class="language-julia hljs">@model function model_definition_example()
    y ~ Beta(1.0, 1.0)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GraphPPL.ModelGenerator{typeof(Main.model_definition_example), Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, GraphPPL.PluginsCollection{Tuple{}}, GraphPPL.DefaultBackend}(Main.model_definition_example, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}(), GraphPPL.PluginsCollection{Tuple{}}(()), GraphPPL.DefaultBackend())</code></pre><p>The model function can accept arguments</p><pre><code class="language-julia hljs">@model function model_definition_example(a, b)
    y ~ Beta(a, b)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GraphPPL.ModelGenerator{typeof(Main.model_definition_example), Base.Pairs{Symbol, Int64, Tuple{Symbol, Symbol}, @NamedTuple{a::Int64, b::Int64}}, GraphPPL.PluginsCollection{Tuple{}}, GraphPPL.DefaultBackend}(Main.model_definition_example, Base.Pairs(:a =&gt; 1, :b =&gt; 2), GraphPPL.PluginsCollection{Tuple{}}(()), GraphPPL.DefaultBackend())</code></pre><p>Note that all argument are converted to keyword arguments and positional arguments are not supported. As a consequence, the models defined with the <code>@model</code> macro can&#39;t use multiple dispatch.</p><pre><code class="language-julia hljs">model_definition_example(a = 1.0, b = 1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GraphPPL.ModelGenerator{typeof(Main.model_definition_example), Base.Pairs{Symbol, Float64, Tuple{Symbol, Symbol}, @NamedTuple{a::Float64, b::Float64}}, GraphPPL.PluginsCollection{Tuple{}}, GraphPPL.DefaultBackend}(Main.model_definition_example, Base.Pairs(:a =&gt; 1.0, :b =&gt; 1.0), GraphPPL.PluginsCollection{Tuple{}}(()), GraphPPL.DefaultBackend())</code></pre><h2 id="The-operator"><a class="docs-heading-anchor" href="#The-operator">The <code>~</code> operator</a><a id="The-operator-1"></a><a class="docs-heading-anchor-permalink" href="#The-operator" title="Permalink"></a></h2><p>The <code>~</code> operator is at the heart of the <code>GraphPPL</code> syntax. It is used to define and specify the distribution of a random variable. In general, we can write <code>x ~ dist(args...)</code> to specify that the random variable <code>x</code> is distributed according to the distribution <code>dist</code> with parameters <code>args...</code>. On the left hand side of the <code>~</code> operator we have a single random variable that doesn&#39;t necessarily have to be defined yet. On the right hand side we have any factor function that takes some arguments. The arguments to the factor function should be defined, either as constants or as other random variables. The expression on the right hand side of the <code>~</code> operator can be a complex expression. For example, we can write <code>x ~ Bernoulli(Beta(sum(ones(10)), 1))</code> as an overly complicated way to define a <code>Bernoulli</code> random variable with a <code>Beta(10, 1)</code> prior.</p><p>Variables created with the <code>~</code> operator can be used in subsequent statements. The following example reimplements our overly complicated <code>Bernoulli</code> random variable by explicitly defining the <code>p</code> parameter:</p><pre><code class="language-julia hljs">@model function tilde_operator_example(x)
    p ~ Beta(10, 1)
    x ~ Bernoulli(p)
end</code></pre><h2 id="The-:-operator"><a class="docs-heading-anchor" href="#The-:-operator">The <code>:=</code> operator</a><a id="The-:-operator-1"></a><a class="docs-heading-anchor-permalink" href="#The-:-operator" title="Permalink"></a></h2><p>Mathematically, the <code>~</code> operator is used to define a stochastic relationship: <code>x ~ dist(args...)</code> means that <code>x</code> is distributed according to <code>dist(args...)</code>. It is therefore mathematically incorrect to use the <code>~</code> operator to denote a deterministic relationship. For example: <code>x ~ 1 + 1</code> does not make sense. However, deterministic relations are often useful in probabilistic modeling. However, the operation we want to perform is significantly different from an ordinary <code>=</code> assignment, since we do want to make a factor node for this deterministic relationship and include it in the factor graph. For these reasons, we introduce the <code>:=</code> operator. The <code>:=</code> operator is an alias to the <code>~</code> operator, that can be used in the same way as the <code>~</code> operator, but it is used to denote deterministic relationships. Note that the <code>:=</code> operator is merely syntactic sugar and is meant to give context to readers as to which relationships are deterministic and which are stochastic. The following example demonstrates the use of the <code>:=</code> operator:</p><pre><code class="language-julia hljs">@model function colon_equal_operator_example(x)
    p ~ Normal(0, 1)
    x := p + p
end</code></pre><h2 id="Broadcasting-with-the-operator"><a class="docs-heading-anchor" href="#Broadcasting-with-the-operator">Broadcasting with the <code>~</code> operator</a><a id="Broadcasting-with-the-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-with-the-operator" title="Permalink"></a></h2><p>The <code>~</code> operator supports broadcasting. This means that we can define multiple random variables at once. For example, we can write <code>x .~ Normal(μ, σ)</code> with <code>μ</code> and <code>σ</code> being vectors of random variables to define multiple random variables at once and store them in the vector <code>x</code>. The following example demonstrates the use of broadcasting with the <code>~</code> operator:</p><pre><code class="language-julia hljs">@model function broadcasting_example()
    local p
    for i in 1:10
        p[i] ~ Beta(1, 1)
    end
    y .~ Bernoulli(p)
end</code></pre><p>In this example, we define 10 random variables <code>p</code> with a <code>Beta(1, 1)</code> prior and then define a vector of random variables <code>y</code> with a <code>Bernoulli</code> distribution with the entries of <code>p</code> as parameters.</p><h2 id="Difference-between-random-variables-and-parameters"><a class="docs-heading-anchor" href="#Difference-between-random-variables-and-parameters">Difference between random variables and parameters</a><a id="Difference-between-random-variables-and-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Difference-between-random-variables-and-parameters" title="Permalink"></a></h2><p>GraphPPL makes an explicit distinction between random variables and parameters, even though they can both enter the model in the same way. Random variables are explicitly present in your factor graph and are not known on model construction (This definition seems backwards since &quot;Random variables&quot; are never truly known, but in case of, for example, data entering your model, we have that we represent the data as a random variable in the factor graph, and even though we would know the value of the data during inference, we don&#39;t know the value yet during model construction). Parameters, on the other hand, are known during model construction and are not present in the factor graph. As an example, we can define the following model:</p><pre><code class="language-julia hljs">@model function recursive_model(depth, y)
    if depth == 0
        y ~ Normal(0, 1)
    else
        x ~ Normal(0, 1)
        y ~ recursive_model(depth = depth - 1)
    end
end</code></pre><p>Here, we use <code>depth</code> as a parameter: It defines the control flow of the model construction, and defines the amount of <code>recursive_model</code> submodels we create. <code>y</code> is a random variable: It is present in the factor graph and is not known during model construction. Therefore, we can never use statements like <code>if y &gt; 0</code> in the model definition, since <code>y</code> is not known during model construction. Conversely, we cannot infer a distribution over <code>depth</code>, since it is a parameter and not a random variable.</p><h2 id="local-keyword"><a class="docs-heading-anchor" href="#local-keyword"><code>local</code> keyword</a><a id="local-keyword-1"></a><a class="docs-heading-anchor-permalink" href="#local-keyword" title="Permalink"></a></h2><p>As is customary in Julia, a <code>for</code> loop opens a local scope. This means that variables defined inside the <code>for</code> loop are not accessible outside of the loop. This can be problematic when defining random variables inside a loop. In similar fashion to Julia, we can define a variable with the <code>local</code> keyword and make it accessible outside of the loop, while setting priors inside the loop. The following example demonstrates the use of the <code>local</code> keyword:</p><pre><code class="language-julia hljs">@model function local_keyword_example()
    local p
    for i in 1:10
        p[i] ~ Beta(1, 1)
    end
    y .~ Bernoulli(p)
end</code></pre><h2 id="The-new-function"><a class="docs-heading-anchor" href="#The-new-function">The <code>new</code> function</a><a id="The-new-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-new-function" title="Permalink"></a></h2><p>GraphPPL explicitly handles the <code>~</code> operator with a single random variable on the left hand side, and predefined random variables as arguments on the right hand side. However, sometimes we want to simultaneously create multiple random variables from the same submodel. One of the situations in which this occurs is in state-space models, where we want to create a datapoint as well as the state of the system at the next timestep as new random variables when invoking a time-slice of the model as a submodel. For this purpose, we introduce the <code>new</code> function. The <code>new</code> function can wrap random variables on the right hand side of the <code>~</code> operator to indicate to <code>GraphPPL</code> that the random variable should be created anew. The following example demonstrates the use of the <code>new</code> function:</p><pre><code class="language-julia hljs">@model function time_slice_ssm(y, x_prev, x_new)
    y ~ Normal(x_prev, 1)
    x_new ~ Normal(x_prev, 1)
end

@model function ssm(y)
    x[1] ~ Normal(0, 1)
    for i in eachindex(y)
        y[i] ~ time_slice_ssm(x_prev = x[i], x_new = new(x[i + 1]))
    end
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>new</code> function is a syntax construct that can be used only within the <code>~</code> expression and does not exist in run-time. <code>GraphPPL</code> cannot define this function as it is a reserved keyword in Julia.</p></div></div><h2 id="The-where-{-meta-...-}-block"><a class="docs-heading-anchor" href="#The-where-{-meta-...-}-block">The <code>where { meta = ... }</code> block</a><a id="The-where-{-meta-...-}-block-1"></a><a class="docs-heading-anchor-permalink" href="#The-where-{-meta-...-}-block" title="Permalink"></a></h2><p>Factor nodes can have arbitrary metadata attached to them with the <code>where { meta = ... }</code> block after the <code>~</code> operator.  For this functionality to work the <a href="../plugins/meta_specification/#GraphPPL.MetaPlugin"><code>GraphPPL.MetaPlugin</code></a> must be enabled. This metadata can be queried by inference packages to modify the inference procedure. For example:</p><pre><code class="language-julia hljs">@model function some_model(a, b)
    x ~ Beta(a, b) where { meta = &quot;Hello, world!&quot; }
end

model = GraphPPL.create_model(
    GraphPPL.with_plugins(
        some_model(a = 1, b = 2),
        GraphPPL.PluginsCollection(GraphPPL.MetaPlugin())
    )
)

ctx   = GraphPPL.getcontext(model)
node  = model[ctx[Beta, 1]]

GraphPPL.getextra(node, :meta)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Hello, world!&quot;</code></pre><p>Other plugins can hook into the <code>where { ... }</code> block with the <a href="../plugins/overview/#GraphPPL.preprocess_plugin"><code>GraphPPL.preprocess_plugin</code></a>.</p><h2 id="Tracking-the-created_by-field"><a class="docs-heading-anchor" href="#Tracking-the-created_by-field">Tracking the <code>created_by</code> field</a><a id="Tracking-the-created_by-field-1"></a><a class="docs-heading-anchor-permalink" href="#Tracking-the-created_by-field" title="Permalink"></a></h2><p>Factor nodes in the models can optionaly save the expressions with which they were created. For this functionality to  work the <a href="../plugins/created_by/#GraphPPL.NodeCreatedByPlugin"><code>GraphPPL.NodeCreatedByPlugin</code></a> plugin must be enabled. For example: </p><pre><code class="language-julia hljs">@model function some_model(a, b)
    x ~ Beta(a, b)
    y ~ Beta(x, 1)
end

model = GraphPPL.create_model(
    GraphPPL.with_plugins(
        some_model(a = 1, b = 2),
        GraphPPL.PluginsCollection(GraphPPL.NodeCreatedByPlugin())
    )
)
ctx    = GraphPPL.getcontext(model)
node_1 = model[ctx[Beta, 1]]
node_2 = model[ctx[Beta, 2]]</code></pre><pre><code class="language-julia hljs">GraphPPL.getextra(node_1, :created_by)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x ~ Beta(a, b)</code></pre><pre><code class="language-julia hljs">GraphPPL.getextra(node_2, :created_by)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">y ~ Beta(x, 1)</code></pre><p>More information about <a href="../plugins/created_by/#GraphPPL.NodeCreatedByPlugin"><code>GraphPPL.NodeCreatedByPlugin</code></a> can be found <a href="../plugins/created_by/#plugins-node-created-by">here</a>.</p><h2 id="The-return-statement"><a class="docs-heading-anchor" href="#The-return-statement">The <code>return</code> statement</a><a id="The-return-statement-1"></a><a class="docs-heading-anchor-permalink" href="#The-return-statement" title="Permalink"></a></h2><p>Model can have the return statement inside of them for early stopping.  The return statement plays no role in <a href="../nested_models/#nested-models">nested models specification</a>, however. The inference packages can also query the return statement of a specific model if needed from its <a href="../developers_guide/#GraphPPL.Context"><code>GraphPPL.Context</code></a>.</p><pre><code class="language-julia hljs">@model function some_model(a, b)
    x ~ Beta(a, b)
    return &quot;Hello, world!&quot;
end

model = GraphPPL.create_model(some_model(a = 1, b = 2))
ctx   = GraphPPL.getcontext(model)
GraphPPL.returnval(ctx)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Hello, world!&quot;</code></pre><h2 id="Nested-models"><a class="docs-heading-anchor" href="#Nested-models">Nested models</a><a id="Nested-models-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-models" title="Permalink"></a></h2><p><code>GraphPPL</code> supports any previously defined model to be used as a submodel in another model. We have dedicated a separate page in the documentation on this topic, which can be found <a href="../nested_models/">here</a>.</p><h2 id="Scopes"><a class="docs-heading-anchor" href="#Scopes">Scopes</a><a id="Scopes-1"></a><a class="docs-heading-anchor-permalink" href="#Scopes" title="Permalink"></a></h2><p>While <code>GraphPPL</code> aims to be as close to Julia as possible, there are some differences in the way scopes are handled. In Julia, a <code>for</code> loop opens a new scope, meaning that variables defined inside the loop are not accessible outside of the loop. While this is also true in <code>GraphPPL</code> and variables can be defined with the <code>local</code> keyword to make them accessible outside of the loop, creating a variable with the same name in two different for-loops will reference the same variable. This is different from Julia, where the two variables would be distinct. The following example demonstrates this behaviour:</p><pre><code class="language-julia hljs">@model function scope_example()
    for i in 1:10
        x[i] ~ Normal(0, 1)
    end
    for i in 1:10
        x[i] ~ Normal(0, 1)
    end
end</code></pre><p>Instead of creating 20 random variables, this model will create 10 random variables and then reuse them in the second loop. This is because of the way <code>GraphPPL</code> handles variable creation. If you want to create 20 distinct random variables, you should use different names for the variables in the two loops.</p><h2 id="Arrays-in-GraphPPL"><a class="docs-heading-anchor" href="#Arrays-in-GraphPPL">Arrays in GraphPPL</a><a id="Arrays-in-GraphPPL-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays-in-GraphPPL" title="Permalink"></a></h2><p>As you can see in the previous examples, arrays in <code>GraphPPL</code> behave slightly differently than in Julia. In <code>GraphPPL</code>, we can define any <code>x[i]</code> as the left hand side of the <code>~</code> operator, without prespecifying <code>x</code> or its size. This trick involves a custom implementation of arrays in <code>GraphPPL</code> that dynamically grows as needed. This means that custom list comprehension statements in <code>GraphPPL</code> could give some unexpected behaviour. These examples are mostly pathological and should in general be avoided. However, if you do need custom list constructions, please wrap the result in <code>GraphPPL.ResizableArray</code> to ensure that factor nodes and submodels accept the array as a valid input. Note that variational constraints might throw exceptions if you try to specify a variational factorization constraint over custom created arrays of random variables.</p><pre><code class="language-julia hljs">@model function array_example()
    x1 ~ Normal(0, 1)
    x2 ~ Normal(0, 1)
    x3 ~ Normal(0, 1)
    x = GraphPPL.ResizableArray([x1, x2, x3])
    y ~ some_submodel(in = x)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../nested_models/">Nested Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Saturday 20 April 2024 10:51">Saturday 20 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

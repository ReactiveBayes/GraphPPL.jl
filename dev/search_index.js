var documenterSearchIndex = {"docs":
[{"location":"transformation-steps/#Model-specification-transformation-steps-for-the-ReactiveMP.jl-backend","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"","category":"section"},{"location":"transformation-steps/#Step-1:-Normalizarion-of-operator-node-arguments","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Step 1: Normalizarion of ~ operator node arguments","text":"","category":"section"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"Any expression of the form ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"lhs ~ Node(..., f(...), ...)","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"is translated to","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"lhs ~ Node(..., var\"#anonymous\" ~ f(...), ...)","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"The only one exception is reference expression of the form x[f(i)] which are left untouched. This step forces model to create an anonymous node for any inner function call within ~ operator expression. In some cases ReactiveMP.jl backend can (and will) optimize this inner anonymous nodes into just function calls. E.g. following example won't create any additional nodes in the model ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"precision = 1.0\n\nnoise ~ NormalMeanVariance(noise_mean, 1.0 / precision) # Since 1.0 and precision are constants inference backend can just apply `/` function to them `/(1.0, precision)`.","category":"page"},{"location":"transformation-steps/#Step-2:-Main-pass","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Step 2: Main pass","text":"","category":"section"},{"location":"transformation-steps/#datavar()-transformation","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"datavar() transformation","text":"","category":"section"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"Any expression of the form ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"y = datavar(args...) # empty options here\n# or \ny = datavar(args...) where { options... }","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"is translated to ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"y = datavar(var\"#model\", options, :y, ensure_type(args[1]), args[2:end]...)","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"where var\"#model\" references to an hidden model variable, ensure_type function ensures that the first argument is a valid type object, rest of the arguments are left untouched. ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"The list of possible options:","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"subject: specifies a subject that will be used to pass data variable related information, see more info in Rocket.jl documentation.\nallow_missing: boolea flag that controls is is possible to pass missing data or not","category":"page"},{"location":"transformation-steps/#randomvar()-transformation","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"randomvar() transformation","text":"","category":"section"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"Any expression of the form ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"x = randomvar(args...) # empty options here\n# or\nx = randomvar(args...) where { options... }","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"is translated to ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"x = randomvar(var\"#model\", options, :x, args...)","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"where var\"#model\" references to an anonymous model variable, arguments are left untouched. ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"The list of possible options (see ReactiveMP.jl documentation for more info about these options):","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"pipeline\nprod_constraint\nprod_strategy\nmarginal_form_constraint\nmarginal_form_check_strategy\nmessages_form_constraint\nmessages_form_check_strategy","category":"page"},{"location":"transformation-steps/#constvar()-transformation","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"constvar() transformation","text":"","category":"section"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"Any expression of the form ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"c = constvar(args...) # constvar's do not support any extra options flags","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"is translated to ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"c = constvar(var\"#model\", :c, args...)","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"where var\"#model\" references to an anonymous model variable, arguments are left untouched.","category":"page"},{"location":"transformation-steps/#Step-3:-Tilde-pass","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Step 3: Tilde pass","text":"","category":"section"},{"location":"transformation-steps/#.0-Node-reference-pass","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"3.0 Node reference pass","text":"","category":"section"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"All expression of the form ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"variable ~ Node(args...)","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"are translated to ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"node, variable ~ Node(args...)","category":"page"},{"location":"transformation-steps/#.1-Node-options-pass","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"3.1 Node options pass","text":"","category":"section"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"All expressions of the form ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"node, variable ~ Node(args...) where { options... }","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"are translated to ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"node, variable ~ Node(args...; options...)","category":"page"},{"location":"transformation-steps/#.2-Functional-relations-pass","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"3.2 Functional relations pass","text":"","category":"section"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"All expression of the form","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"node, variable ~ Node(args...; options...)","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"represent a valid functional dependency between variable and args.... There are 2 options for further modification of this expression: ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"If variable has been created before with the help of datavar() or randomvar() functions the previous expression is translated to:","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"node = make_node(var\"#model\", options, variable, args...) ","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"If variable has not been created before the expression is translated to:","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"node = make_node(var\"#model\", options, AutoVar(:variable), args...)","category":"page"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"that internally creates a new variable in the model.","category":"page"},{"location":"transformation-steps/#Step-4:-Final-pass","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Step 4: Final pass","text":"","category":"section"},{"location":"transformation-steps/","page":"Model specification transformation steps for the ReactiveMP.jl backend","title":"Model specification transformation steps for the ReactiveMP.jl backend","text":"During the final pass GraphPPL.jl inject before any return ... call (and also at the very end) the activate! call to the var#\"model\"","category":"page"},{"location":"user-guide/#User-guide","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Probabilistic models incorporate elements of randomness to describe an event or phenomenon by using random variables and probability theory. A probabilistic model can be represented visually by using probabilistic graphical models (PGMs). A factor graph is a type of PGM that is well suited to cast inference tasks in terms of graphical manipulations.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"GraphPPL.jl is a Julia package presenting a model specification language for probabilistic models. ","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"note: Note\nGraphPPL.jl does not work without extra \"backend\" package. Currently the only one available \"backend\" package is ReactiveMP.jl.","category":"page"},{"location":"user-guide/#user-guide-model-specification","page":"User guide","title":"Model specification","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"The GraphPPL.jl package exports the @model macro for model specification. This @model macro accepts two arguments: model options and the model specification itself in a form of regular Julia function. For example: ","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@model [ option1 = ..., option2 = ... ] function model_name(model_arguments...; model_keyword_arguments...)\n    # model specification here\n    return ...\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Model options, model_arguments and model_keyword_arguments are optional and may be omitted:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@model function model_name()\n    # model specification here\n    return ...\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"note: Note\noptions, constraints and meta keyword arguments are reserved and cannot be used in model_keyword_arguments.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"The @model macro returns a regular Julia function (in this example model_name()) which can be executed as usual. It returns a reference to a model object itself and a tuple of a user specified return variables, e.g:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@model function my_model(model_arguments...)\n    # model specification here\n    # ...\n    return x, y\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"model, (x, y) = my_model(model_arguments...)","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"It is not necessary to return anything from the model, in that case GraphPPL.jl will automatically inject return nothing to the end of the model function.","category":"page"},{"location":"user-guide/#A-full-example-before-diving-in","page":"User guide","title":"A full example before diving in","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Before presenting the details of the model specification syntax, an example of a probabilistic model is given. Here is an example of a simple state space model with latent random variables x and noisy observations y:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@model [ options... ] function state_space_model(n_observations, noise_variance)\n\n    x = randomvar(n_observations)\n    y = datavar(Float64, n_observations)\n\n    x[1] ~ NormalMeanVariance(0.0, 100.0)\n\n    for i in 2:n_observations\n       x[i] ~ x[i - 1] + 1.0\n       y[i] ~ NormalMeanVariance(x[i], noise_var)\n    end\n\n    return x, y\nend","category":"page"},{"location":"user-guide/#Graph-variables-creation","page":"User guide","title":"Graph variables creation","text":"","category":"section"},{"location":"user-guide/#Constants","page":"User guide","title":"Constants","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Any runtime constant passed to a model as a model argument will be automatically converted to a fixed constant in the graph model at runtime. Sometimes it might be useful to create constants by hand (e.g. to avoid copying large matrices across the model and to avoid extensive memory allocations).","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"You can create a constant within a model specification macro with constvar() function. For example:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"c = constvar(1.0)\n\nfor i in 2:n\n    x[i] ~ x[i - 1] + c # Reuse the same reference to a constant 1.0\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Additionally you can specify an extra ::ConstVariable type for some of the model arguments. In this case macro automatically converts them to a single constant using constvar() function. E.g.:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@model function model_name(nsamples::Int, c::ConstVariable)\n    # ...\n    # no need to call for a constvar() here\n    for i in 2:n\n        x[i] ~ x[i - 1] + c # Reuse the same reference to a constant `c`\n    end\n    # ...\n    return ...\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"note: Note\n::ConstVariable annotation does not play role in Julia's multiple dispatch. GraphPPL.jl removes this annotation and replaces it with ::Any.","category":"page"},{"location":"user-guide/#Data-variables","page":"User guide","title":"Data variables","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"It is important to have a mechanism to pass data values to the model. You can create data inputs with datavar() function. As a first argument it accepts a type specification and optional dimensionality (as additional arguments or as a tuple).","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Examples: ","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"y = datavar(Float64) # Creates a single data input with `y` as identificator\ny = datavar(Float64, n) # Returns a vector of  `y_i` data input objects with length `n`\ny = datavar(Float64, n, m) # Returns a matrix of `y_i_j` data input objects with size `(n, m)`\ny = datavar(Float64, (n, m)) # It is also possible to use a tuple for dimensionality","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"datavar() call supports where { options... } block for extra options specification. Read ReactiveMP.jl documentation to know more about possible creation options.","category":"page"},{"location":"user-guide/#Random-variables","page":"User guide","title":"Random variables","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"There are several ways to create random variables. The first one is an explicit call to randomvar() function. By default it doesn't accept any argument, creates a single random variable in the model and returns it. It is also possible to pass dimensionality arguments to randomvar() function in the same way as for the datavar() function.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Examples: ","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"x = randomvar() # Returns a single random variable which can be used later in the model\nx = randomvar(n) # Returns an vector of random variables with length `n`\nx = randomvar(n, m) # Returns a matrix of random variables with size `(n, m)`\nx = randomvar((n, m)) # It is also possible to use a tuple for dimensionality","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"In the same way as datavar() function, randomvar() options supports where { options... } block for exxtra options. Read ReactiveMP.jl documentation to know more about possible creation options.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"The second way to create a random variable is to create a node with the ~ operator. If the random variable has not yet been created before this call, it will be created automatically during the creation of the node. Read more about the ~ operator below.","category":"page"},{"location":"user-guide/#Node-creation","page":"User guide","title":"Node creation","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Factor nodes are used to define a relationship between random variables and/or constants and data inputs. A factor node defines a probability distribution over selected random variables. ","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"We model a random variable by a probability distribution using the ~ operator. For example, to create a random variable y which is modeled by a Normal distribution, where its mean and variance are controlled by the random variables m and v respectively, we define","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"m = randomvar()\nv = randomvar()\ny ~ NormalMeanVariance(m, v) # Creates a `y` random variable automatically","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"a = randomvar()\nb = randomvar()\nc ~ a + b","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"note: Note\nThe GraphPPL.jl package uses the ~ operator for modelling both stochastic and deterministic relationships between random variables.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"The @model macro automatically resolves any inner function calls into anonymous extra nodes in case this inner function call is a non-linear transformations. But it is important to note that the inference backend will try to optimize inner non-linear deterministic function calls in the case where all arguments are constants or data inputs. For example:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"noise ~ NormalMeanVariance(mean, inv(precision)) # Will create a non-linear node in case if `precision` is a random variable. Won't create an additional non-linear node in case if `precision` is a constant or data input.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"It is possible to use any functional expression within the ~ operator arguments list. The only one exception is the ref expression (e.g x[i]). All reference expressions within the ~ operator arguments list are left untouched during model parsing. This means that the model parser will not create unnecessary nodes when only simple indexing is involved.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"y ~ NormalMeanVariance(x[i - 1], variance) # While in principle `i - 1` is an inner function call (`-(i, 1)`) model parser will leave it untouched and won't create any anonymous nodes for `ref` expressions.\n\ny ~ NormalMeanVariance(A * x[i - 1], variance) # This example will create a `*` anonymous node (in case if x[i - 1] is a random variable) and leave `x[i - 1]` untouched.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"It is also possible to return a node reference from the ~ operator. Use the following syntax:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"node, y ~ NormalMeanVariance(mean, var)","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Having a node reference can be useful in case the user wants to return it from a model and to use it later on to specify initial joint marginal distributions.","category":"page"},{"location":"user-guide/#Node-creation-options","page":"User guide","title":"Node creation options","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"To pass optional arguments to the node creation constructor the user can use the where { options...  } options specification syntax.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Example:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean)q(y_var)q(y) } # mean-field factorisation over q","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"A list of some of the available options specific to ReactiveMP.jl is presented below. For the full list we refer the reader to the ReactiveMP.jl documentation.","category":"page"},{"location":"user-guide/#Factorisation-constraint-option","page":"User guide","title":"Factorisation constraint option","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Users can specify a factorisation constraint over the approximate posterior q for variational inference. The general syntax for factorisation constraints over q is the following:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"variable ~ Node(node_arguments...) where { q = RecognitionFactorisationConstraint }","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"where RecognitionFactorisationConstraint can be the following","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"MeanField()","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Automatically specifies a mean-field factorisation","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Example:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"y ~ NormalMeanVariance(y_mean, y_var) where { q = MeanField() }","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"FullFactorisation()","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Automatically specifies a full factorisation","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Example:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"y ~ NormalMeanVariance(y_mean, y_var) where { q = FullFactorisation() }","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"q(μ)q(v)q(out) or q(μ) * q(v) * q(out)","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"A user can specify any factorisation he wants as the multiplication of q(interface_names...) factors. As interface names the user can use the interface names of an actual node (read node's documentation), its aliases (if available) or actual random variable names present in the ~ operator expression.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Examples: ","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"# Using interface names of a `NormalMeanVariance` node for factorisation constraint. \n# Call `?NormalMeanVariance` to know more about interface names for some node\ny ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ)q(v)q(out) }\ny ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ, v)q(out) }\n\n# Using interface names aliases of a `NormalMeanVariance` node for factorisation constraint. \n# Call `?NormalMeanVariance` to know more about interface names aliases for some node\n# In general aliases correspond to the function names for distribution parameters\ny ~ NormalMeanVariance(y_mean, y_var) where { q = q(mean)q(var)q(out) }\ny ~ NormalMeanVariance(y_mean, y_var) where { q = q(mean, var)q(out) }\n\n# Using random variables names from `~` operator expression\ny ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean)q(y_var)q(y) }\ny ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean, y_var)q(y) }\n\n# All methods can be combined easily\ny ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ)q(y_var)q(out) }\ny ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean, v)q(y) }","category":"page"},{"location":"user-guide/#Metadata-option","page":"User guide","title":"Metadata option","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Is is possible to pass any extra metadata to a factor node with the meta option. Metadata can be later accessed in message computation rules:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"z ~ f(x, y) where { meta = ... }","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"For more information about possible node creation options we refer the reader to the ReactiveMP.jl documentation.","category":"page"},{"location":"user-guide/#user-guide-constraints-specification","page":"User guide","title":"Constraints specification","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"GraphPPL.jl exports @constraints macro for the extra constraints specification that can be used during the inference step in ReactiveMP.jl package.","category":"page"},{"location":"user-guide/#General-syntax","page":"User guide","title":"General syntax","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints macro accepts both regular julia functions and just simple blocks. In the first case it returns a function that return constraints and in the second case it returns constraints directly.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"myconstraints = @constraints begin \n    q(x) :: PointMass\n    q(x, y) = q(x)q(y)\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"or ","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints function make_constraints(flag)\n    q(x) :: PointMass\n    if flag\n        q(x, y) = q(x)q(y)\n    end\nend\n\nmyconstraints = make_constraints(true)","category":"page"},{"location":"user-guide/#Marginal-and-messages-form-constraints","page":"User guide","title":"Marginal and messages form constraints","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"To specify marginal or messages form constraints @constraints macro uses :: operator (in the similar way as Julia uses it for type specification)","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"The following constraint","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints begin \n    q(x) :: PointMass\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"indicates that the resulting marginal of the variable (or array of variables) named x must be approximated with a PointMass object. To set messages form constraint @constraints macro uses μ(...) instead of q(...):","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints begin \n    q(x) :: PointMass\n    μ(x) :: SampleList \n    # it is possible to assign different form constraints on the same variable \n    # both for the marginal and for the messages \nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints macro understands \"stacked\" form constraints. For example the following form constraint","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints begin \n    q(x) :: SampleList(1000, LeftProposal()) :: PointMass\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"indicates that the resulting posterior first maybe approximated with a SampleList and in addition the result of this approximation should be approximated as a PointMass.  For more information about form constraints we refer the reader to the ReactiveMP.jl documentation.","category":"page"},{"location":"user-guide/#Factorisation-constraints-on-posterior-distribution-q()","page":"User guide","title":"Factorisation constraints on posterior distribution q()","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@model macro specifies generative model p(s, y) where s is a set of random variables and y is a set of obseervations. In a nutshell the goal of probabilistic programming is to find p(s|y). p(s|y) during the inference procedure can be approximated with another q(s) using e.g. KL divergency. By default there are no extra factorisation constraints on q(s) and the result is q(s) = p(s|y). However, inference may be not tractable for every model without extra factorisation constraints. To circumvent this, GraphPPL.jl and ReactiveMP.jl accepts optional factorisation constraints specification syntax:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"For example:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints begin \n    q(x, y) = q(x)q(y)\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"specifies a so-called mean-field assumption on variables x and y in the model. Futhermore, if x is an array of variables in our model we may induce extra mean-field assumption on x in the following way.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints begin \n    q(x, y) = q(x)q(y)\n    q(x) = q(x[begin])..q(x[end])\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"These constraints specifies a mean-field assumption between variables x and y (either single variable or collection of variables) and additionally specifies mean-field assumption on variables x_i.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"note: Note\n@constraints macro does not support matrix-based collections of variables. E.g. it is not possible to write q(x[begin, begin])..q(x[end, end])","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"It is possible to write more complex factorisation constraints, for example:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints begin \n    q(x, y) = q(x[begin], y[begin])..q(x[end], y[end])\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Specifies a mean-field assumption between collection of variables named x and y only for variables with different indices. Another example is","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@constraints function make_constraints(k)\n    q(x) = q(x[begin:k])q(x[k+1:end])\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"In this example we specify a mean-field assumption between a set of variables x[begin:k] and x[k+1:end]. ","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"To create a model with extra constraints user may use optional constraints keyword argument for the model function:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@model function my_model(arguments...)\n   ...\nend\n\nconstraints = @constraints begin \n    ...\nend\n\nmodel, (x, y) = model_name(arguments..., constraints = constraints)","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"For more information about factorisation constraints we refer the reader to the ReactiveMP.jl documentation.","category":"page"},{"location":"user-guide/#user-guide-meta-specification","page":"User guide","title":"Meta specification","text":"","category":"section"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"Some nodes in ReactiveMP.jl accept optional meta structure that may be used to change or customise the inference procedure. As an example GCV node accepts the approxximation method that will be used to approximate non-conjugate relationships between variables in this node. GraphPPL.jl exports @meta macro to specify node-specific meta information. For example:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"meta = @meta begin \n    GCV(x, k, w) -> GCVMetadata(GaussHermiteCubature(20))\nend","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"indicates, that for every GCV node in the model that has x, k and w as connected variables the GCVMetadata(GaussHermiteCubature(20)) meta object should be used.","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@meta accepts function expression in the same way as @constraints macro, e.g:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@meta make_meta(n)\n    GCV(x, k, w) -> GCVMetadata(GaussHermiteCubature(n))\nend\n\nmeta = make_meta(20)","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"To create a model with extra meta options user may use optional meta keyword argument for the model function:","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"@model function my_model(arguments...)\n   ...\nend\n\nmeta = @meta begin \n    ...\nend\n\nmodel, (x, y) = model_name(arguments..., meta = meta)","category":"page"},{"location":"user-guide/","page":"User guide","title":"User guide","text":"For more information about the meta specification we refer the reader to the ReactiveMP.jl documentation.","category":"page"},{"location":"#ReactiveMP.jl-Documentation","page":"Home","title":"ReactiveMP.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for GraphPPL.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Useful links:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ReactiveMP.jl documentation\nUser guide: Model specification\nUser guide: Constraints specification\nUser guide: Meta specification","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"user-guide.md\",\n  \"transformation-steps.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"GraphPPL.ishead\nGraphPPL.isblock\nGraphPPL.iscall","category":"page"},{"location":"utils/#GraphPPL.ishead","page":"Utils","title":"GraphPPL.ishead","text":"ishead(expr, head)\n\nChecks if expr has head set to head. Returns false if expr is not a valid Julia Expr object.\n\n\n\n\n\n","category":"function"},{"location":"utils/#GraphPPL.isblock","page":"Utils","title":"GraphPPL.isblock","text":"isblock(expr)\n\nShorthand for ishead(expr, :block)\n\nSee also: ishead\n\n\n\n\n\n","category":"function"},{"location":"utils/#GraphPPL.iscall","page":"Utils","title":"GraphPPL.iscall","text":"iscall(expr)\niscall(expr, fsym)\n\nShorthand for ishead(expr, :call) and arguments length check. If an extra fsym argument specified function checks if fsym function being called.\n\nSee also: ishead\n\n\n\n\n\n","category":"function"}]
}

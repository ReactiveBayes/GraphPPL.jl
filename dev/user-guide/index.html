<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User guide · GraphPPL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphPPL.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>User guide</a><ul class="internal"><li><a class="tocitem" href="#user-guide-model-specification"><span>Model specification</span></a></li><li><a class="tocitem" href="#A-full-example-before-diving-in"><span>A full example before diving in</span></a></li><li><a class="tocitem" href="#Graph-variables-creation"><span>Graph variables creation</span></a></li><li><a class="tocitem" href="#Node-creation"><span>Node creation</span></a></li><li><a class="tocitem" href="#user-guide-constraints-specification"><span>Constraints specification</span></a></li><li><a class="tocitem" href="#user-guide-meta-specification"><span>Meta specification</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Utils</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/biaslab/GraphPPL.jl/blob/master/docs/src/user-guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="User-guide"><a class="docs-heading-anchor" href="#User-guide">User guide</a><a id="User-guide-1"></a><a class="docs-heading-anchor-permalink" href="#User-guide" title="Permalink"></a></h1><p>Probabilistic models incorporate elements of randomness to describe an event or phenomenon by using random variables and probability theory. A probabilistic model can be represented visually by using probabilistic graphical models (PGMs). A factor graph is a type of PGM that is well suited to cast inference tasks in terms of graphical manipulations.</p><p><code>GraphPPL.jl</code> is a Julia package presenting a model specification language for probabilistic models. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>GraphPPL.jl</code> does not work without extra &quot;backend&quot; package. Currently the only one available &quot;backend&quot; package is <code>ReactiveMP.jl</code>.</p></div></div><h2 id="user-guide-model-specification"><a class="docs-heading-anchor" href="#user-guide-model-specification">Model specification</a><a id="user-guide-model-specification-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification" title="Permalink"></a></h2><p>The <code>GraphPPL.jl</code> package exports the <code>@model</code> macro for model specification. This <code>@model</code> macro accepts two arguments: model options and the model specification itself in a form of regular Julia function. For example: </p><pre><code class="language-julia hljs">@model [ option1 = ..., option2 = ... ] function model_name(model_arguments...; model_keyword_arguments...)
    # model specification here
    return ...
end</code></pre><p>Model options, <code>model_arguments</code> and <code>model_keyword_arguments</code> are optional and may be omitted:</p><pre><code class="language-julia hljs">@model function model_name()
    # model specification here
    return ...
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>options</code>, <code>constraints</code> and <code>meta</code> keyword arguments are reserved and cannot be used in <code>model_keyword_arguments</code>.</p></div></div><p>The <code>@model</code> macro returns a regular Julia function (in this example <code>model_name()</code>) which can be executed as usual. It returns a reference to a model object itself and a tuple of a user specified return variables, e.g:</p><pre><code class="language-julia hljs">@model function my_model(model_arguments...)
    # model specification here
    # ...
    return x, y
end</code></pre><pre><code class="language-julia hljs">model, (x, y) = my_model(model_arguments...)</code></pre><p>It is not necessary to return anything from the model, in that case <code>GraphPPL.jl</code> will automatically inject <code>return nothing</code> to the end of the model function.</p><h2 id="A-full-example-before-diving-in"><a class="docs-heading-anchor" href="#A-full-example-before-diving-in">A full example before diving in</a><a id="A-full-example-before-diving-in-1"></a><a class="docs-heading-anchor-permalink" href="#A-full-example-before-diving-in" title="Permalink"></a></h2><p>Before presenting the details of the model specification syntax, an example of a probabilistic model is given. Here is an example of a simple state space model with latent random variables <code>x</code> and noisy observations <code>y</code>:</p><pre><code class="language-julia hljs">@model [ options... ] function state_space_model(n_observations, noise_variance)

    x = randomvar(n_observations)
    y = datavar(Float64, n_observations)

    x[1] ~ NormalMeanVariance(0.0, 100.0)

    for i in 2:n_observations
       x[i] ~ x[i - 1] + 1.0
       y[i] ~ NormalMeanVariance(x[i], noise_var)
    end

    return x, y
end</code></pre><h2 id="Graph-variables-creation"><a class="docs-heading-anchor" href="#Graph-variables-creation">Graph variables creation</a><a id="Graph-variables-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-variables-creation" title="Permalink"></a></h2><h3 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h3><p>Any runtime constant passed to a model as a model argument will be automatically converted to a fixed constant in the graph model at runtime. Sometimes it might be useful to create constants by hand (e.g. to avoid copying large matrices across the model and to avoid extensive memory allocations).</p><p>You can create a constant within a model specification macro with <code>constvar()</code> function. For example:</p><pre><code class="language-julia hljs">c = constvar(1.0)

for i in 2:n
    x[i] ~ x[i - 1] + c # Reuse the same reference to a constant 1.0
end</code></pre><p>Additionally you can specify an extra <code>::ConstVariable</code> type for some of the model arguments. In this case macro automatically converts them to a single constant using <code>constvar()</code> function. E.g.:</p><pre><code class="language-julia hljs">@model function model_name(nsamples::Int, c::ConstVariable)
    # ...
    # no need to call for a constvar() here
    for i in 2:n
        x[i] ~ x[i - 1] + c # Reuse the same reference to a constant `c`
    end
    # ...
    return ...
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>::ConstVariable</code> annotation does not play role in Julia&#39;s multiple dispatch. <code>GraphPPL.jl</code> removes this annotation and replaces it with <code>::Any</code>.</p></div></div><h3 id="Data-variables"><a class="docs-heading-anchor" href="#Data-variables">Data variables</a><a id="Data-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Data-variables" title="Permalink"></a></h3><p>It is important to have a mechanism to pass data values to the model. You can create data inputs with <code>datavar()</code> function. As a first argument it accepts a type specification and optional dimensionality (as additional arguments or as a tuple).</p><p>Examples: </p><pre><code class="language-julia hljs">y = datavar(Float64) # Creates a single data input with `y` as identificator
y = datavar(Float64, n) # Returns a vector of  `y_i` data input objects with length `n`
y = datavar(Float64, n, m) # Returns a matrix of `y_i_j` data input objects with size `(n, m)`
y = datavar(Float64, (n, m)) # It is also possible to use a tuple for dimensionality</code></pre><p><code>datavar()</code> call supports <code>where { options... }</code> block for extra options specification. Read <code>ReactiveMP.jl</code> documentation to know more about possible creation options.</p><h3 id="Random-variables"><a class="docs-heading-anchor" href="#Random-variables">Random variables</a><a id="Random-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Random-variables" title="Permalink"></a></h3><p>There are several ways to create random variables. The first one is an explicit call to <code>randomvar()</code> function. By default it doesn&#39;t accept any argument, creates a single random variable in the model and returns it. It is also possible to pass dimensionality arguments to <code>randomvar()</code> function in the same way as for the <code>datavar()</code> function.</p><p>Examples: </p><pre><code class="language-julia hljs">x = randomvar() # Returns a single random variable which can be used later in the model
x = randomvar(n) # Returns an vector of random variables with length `n`
x = randomvar(n, m) # Returns a matrix of random variables with size `(n, m)`
x = randomvar((n, m)) # It is also possible to use a tuple for dimensionality</code></pre><p>In the same way as <code>datavar()</code> function, <code>randomvar()</code> options supports <code>where { options... }</code> block for exxtra options. Read <code>ReactiveMP.jl</code> documentation to know more about possible creation options.</p><p>The second way to create a random variable is to create a node with the <code>~</code> operator. If the random variable has not yet been created before this call, it will be created automatically during the creation of the node. Read more about the <code>~</code> operator below.</p><h2 id="Node-creation"><a class="docs-heading-anchor" href="#Node-creation">Node creation</a><a id="Node-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Node-creation" title="Permalink"></a></h2><p>Factor nodes are used to define a relationship between random variables and/or constants and data inputs. A factor node defines a probability distribution over selected random variables. </p><p>We model a random variable by a probability distribution using the <code>~</code> operator. For example, to create a random variable <code>y</code> which is modeled by a Normal distribution, where its mean and variance are controlled by the random variables <code>m</code> and <code>v</code> respectively, we define</p><pre><code class="language-julia hljs">m = randomvar()
v = randomvar()
y ~ NormalMeanVariance(m, v) # Creates a `y` random variable automatically</code></pre><pre><code class="language-julia hljs">a = randomvar()
b = randomvar()
c ~ a + b</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>GraphPPL.jl</code> package uses the <code>~</code> operator for modelling both stochastic and deterministic relationships between random variables.</p></div></div><p>The <code>@model</code> macro automatically resolves any inner function calls into anonymous extra nodes in case this inner function call is a non-linear transformations. But it is important to note that the inference backend will try to optimize inner non-linear deterministic function calls in the case where all arguments are constants or data inputs. For example:</p><pre><code class="language-julia hljs">noise ~ NormalMeanVariance(mean, inv(precision)) # Will create a non-linear node in case if `precision` is a random variable. Won&#39;t create an additional non-linear node in case if `precision` is a constant or data input.</code></pre><p>It is possible to use any functional expression within the <code>~</code> operator arguments list. The only one exception is the <code>ref</code> expression (e.g <code>x[i]</code>). All reference expressions within the <code>~</code> operator arguments list are left untouched during model parsing. This means that the model parser will not create unnecessary nodes when only simple indexing is involved.</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(x[i - 1], variance) # While in principle `i - 1` is an inner function call (`-(i, 1)`) model parser will leave it untouched and won&#39;t create any anonymous nodes for `ref` expressions.

y ~ NormalMeanVariance(A * x[i - 1], variance) # This example will create a `*` anonymous node (in case if x[i - 1] is a random variable) and leave `x[i - 1]` untouched.</code></pre><p>It is also possible to return a node reference from the <code>~</code> operator. Use the following syntax:</p><pre><code class="language-julia hljs">node, y ~ NormalMeanVariance(mean, var)</code></pre><p>Having a node reference can be useful in case the user wants to return it from a model and to use it later on to specify initial joint marginal distributions.</p><h3 id="Broadcasting-syntax"><a class="docs-heading-anchor" href="#Broadcasting-syntax">Broadcasting syntax</a><a id="Broadcasting-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-syntax" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Broadcasting syntax requires at least v2.1.0 of <code>GraphPPL.jl</code> </p></div></div><p>GraphPPL support broadcasting for <code>~</code> operator in the exact same way as Julia itself. A user is free to write an expression of the following form:</p><pre><code class="language-julia hljs">y = datavar(Float64, n)
y .~ NormalMeanVariance(0.0, 1.0) # &lt;- i.i.d observations</code></pre><p>More complex expression are also allowed:</p><pre><code class="language-julia hljs">m ~ NormalMeanPrecision(0.0, 0.0001)
t ~ Gamma(1.0, 1.0)

y = randomvar(Float64, n)
y .~ NormalMeanPrecision(m, t)</code></pre><pre><code class="language-julia hljs">A = constvar(...)
x = randomvar(n)
y = datavar(Vector{Float64}, n)

w         ~ Wishart(3, diageye(2))
x[1]      ~ MvNormalMeanPrecision(zeros(2), diageye(2))
x[2:end] .~ A .* x[1:end-1] # &lt;- State-space model with transition matrix A
y        .~ MvNormalMeanPrecision(x, w) # &lt;- Observations with unknown precision matrix</code></pre><p>Note, however, that all variables that take part in the broadcasting operation must be defined before either with <code>randomvar</code> or <code>datavar</code>. The exception here is constants that are automatically converted to their <code>constvar</code> equivalent. If you want to prevent broadcasting for some constant (e.g. if you want to add a vector to a multivariate Gaussian distribution) use explicit <code>constvar</code> call:</p><pre><code class="language-julia hljs"># Suppose `x` is a 2-dimensional Gaussian distribution
z .~ x .+ constvar([ 1, 1 ])
# Which is equivalent to 
for i in 1:n
   z[i] ~ x[i] + constvar([ 1, 1 ])
end</code></pre><p>Without explicit <code>constvar</code> Julia&#39;s broadcasting machinery would instead attempt to unroll for loop in the following way:</p><pre><code class="language-julia hljs"># Without explicit `constvar`
z .~ x .+ [ 1, 1 ]
# Which is equivalent to 
array = [1, 1]
for i in 1:n
   z[i] ~ x[i] + array[i] # This is wrong if `x[i]` is supposed to be a multivariate Gaussian 
end</code></pre><p>Read more about how broadcasting machinery works in Julia in <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">the official documentation</a>.</p><h3 id="Node-creation-options"><a class="docs-heading-anchor" href="#Node-creation-options">Node creation options</a><a id="Node-creation-options-1"></a><a class="docs-heading-anchor-permalink" href="#Node-creation-options" title="Permalink"></a></h3><p>To pass optional arguments to the node creation constructor the user can use the <code>where { options...  }</code> options specification syntax.</p><p>Example:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean)q(y_var)q(y) } # mean-field factorisation over q</code></pre><p>A list of some of the available options specific to <code>ReactiveMP.jl</code> is presented below. For the full list we refer the reader to the <code>ReactiveMP.jl</code> documentation.</p><h4 id="Factorisation-constraint-option"><a class="docs-heading-anchor" href="#Factorisation-constraint-option">Factorisation constraint option</a><a id="Factorisation-constraint-option-1"></a><a class="docs-heading-anchor-permalink" href="#Factorisation-constraint-option" title="Permalink"></a></h4><p>Users can specify a factorisation constraint over the approximate posterior <code>q</code> for variational inference. The general syntax for factorisation constraints over <code>q</code> is the following:</p><pre><code class="language-julia hljs">variable ~ Node(node_arguments...) where { q = RecognitionFactorisationConstraint }</code></pre><p>where <code>RecognitionFactorisationConstraint</code> can be the following</p><ol><li><code>MeanField()</code></li></ol><p>Automatically specifies a mean-field factorisation</p><p>Example:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(y_mean, y_var) where { q = MeanField() }</code></pre><ol><li><code>FullFactorisation()</code></li></ol><p>Automatically specifies a full factorisation</p><p>Example:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(y_mean, y_var) where { q = FullFactorisation() }</code></pre><ol><li><code>q(μ)q(v)q(out)</code> or <code>q(μ) * q(v) * q(out)</code></li></ol><p>A user can specify any factorisation he wants as the multiplication of <code>q(interface_names...)</code> factors. As interface names the user can use the interface names of an actual node (read node&#39;s documentation), its aliases (if available) or actual random variable names present in the <code>~</code> operator expression.</p><p>Examples: </p><pre><code class="language-julia hljs"># Using interface names of a `NormalMeanVariance` node for factorisation constraint. 
# Call `?NormalMeanVariance` to know more about interface names for some node
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ)q(v)q(out) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ, v)q(out) }

# Using interface names aliases of a `NormalMeanVariance` node for factorisation constraint. 
# Call `?NormalMeanVariance` to know more about interface names aliases for some node
# In general aliases correspond to the function names for distribution parameters
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(mean)q(var)q(out) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(mean, var)q(out) }

# Using random variables names from `~` operator expression
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean)q(y_var)q(y) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean, y_var)q(y) }

# All methods can be combined easily
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ)q(y_var)q(out) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean, v)q(y) }</code></pre><h4 id="Metadata-option"><a class="docs-heading-anchor" href="#Metadata-option">Metadata option</a><a id="Metadata-option-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata-option" title="Permalink"></a></h4><p>Is is possible to pass any extra metadata to a factor node with the <code>meta</code> option. Metadata can be later accessed in message computation rules:</p><pre><code class="language-julia hljs">z ~ f(x, y) where { meta = ... }</code></pre><p>For more information about possible node creation options we refer the reader to the <code>ReactiveMP.jl</code> documentation.</p><h2 id="user-guide-constraints-specification"><a class="docs-heading-anchor" href="#user-guide-constraints-specification">Constraints specification</a><a id="user-guide-constraints-specification-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-constraints-specification" title="Permalink"></a></h2><p><code>GraphPPL.jl</code> exports <code>@constraints</code> macro for the extra constraints specification that can be used during the inference step in <code>ReactiveMP.jl</code> package.</p><h3 id="General-syntax"><a class="docs-heading-anchor" href="#General-syntax">General syntax</a><a id="General-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#General-syntax" title="Permalink"></a></h3><p><code>@constraints</code> macro accepts both regular julia functions and just simple blocks. In the first case it returns a function that return constraints and in the second case it returns constraints directly.</p><pre><code class="language-julia hljs">myconstraints = @constraints begin 
    q(x) :: PointMass
    q(x, y) = q(x)q(y)
end</code></pre><p>or </p><pre><code class="language-julia hljs">@constraints function make_constraints(flag)
    q(x) :: PointMass
    if flag
        q(x, y) = q(x)q(y)
    end
end

myconstraints = make_constraints(true)</code></pre><h3 id="Marginal-and-messages-form-constraints"><a class="docs-heading-anchor" href="#Marginal-and-messages-form-constraints">Marginal and messages form constraints</a><a id="Marginal-and-messages-form-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Marginal-and-messages-form-constraints" title="Permalink"></a></h3><p>To specify marginal or messages form constraints <code>@constraints</code> macro uses <code>::</code> operator (in the similar way as Julia uses it for type specification)</p><p>The following constraint</p><pre><code class="language-julia hljs">@constraints begin 
    q(x) :: PointMass
end</code></pre><p>indicates that the resulting marginal of the variable (or array of variables) named <code>x</code> must be approximated with a <code>PointMass</code> object. To set messages form constraint <code>@constraints</code> macro uses <code>μ(...)</code> instead of <code>q(...)</code>:</p><pre><code class="language-julia hljs">@constraints begin 
    q(x) :: PointMass
    μ(x) :: SampleList 
    # it is possible to assign different form constraints on the same variable 
    # both for the marginal and for the messages 
end</code></pre><p><code>@constraints</code> macro understands &quot;stacked&quot; form constraints. For example the following form constraint</p><pre><code class="language-julia hljs">@constraints begin 
    q(x) :: SampleList(1000, LeftProposal()) :: PointMass
end</code></pre><p>indicates that the resulting posterior first maybe approximated with a <code>SampleList</code> and in addition the result of this approximation should be approximated as a <code>PointMass</code>.  For more information about form constraints we refer the reader to the <code>ReactiveMP.jl</code> documentation.</p><h3 id="Factorisation-constraints-on-posterior-distribution-q()"><a class="docs-heading-anchor" href="#Factorisation-constraints-on-posterior-distribution-q()">Factorisation constraints on posterior distribution <code>q()</code></a><a id="Factorisation-constraints-on-posterior-distribution-q()-1"></a><a class="docs-heading-anchor-permalink" href="#Factorisation-constraints-on-posterior-distribution-q()" title="Permalink"></a></h3><p><code>@model</code> macro specifies generative model <code>p(s, y)</code> where <code>s</code> is a set of random variables and <code>y</code> is a set of obseervations. In a nutshell the goal of probabilistic programming is to find <code>p(s|y)</code>. <code>p(s|y)</code> during the inference procedure can be approximated with another <code>q(s)</code> using e.g. KL divergency. By default there are no extra factorisation constraints on <code>q(s)</code> and the result is <code>q(s) = p(s|y)</code>. However, inference may be not tractable for every model without extra factorisation constraints. To circumvent this, <code>GraphPPL.jl</code> and <code>ReactiveMP.jl</code> accepts optional factorisation constraints specification syntax:</p><p>For example:</p><pre><code class="language-julia hljs">@constraints begin 
    q(x, y) = q(x)q(y)
end</code></pre><p>specifies a so-called mean-field assumption on variables <code>x</code> and <code>y</code> in the model. Futhermore, if <code>x</code> is an array of variables in our model we may induce extra mean-field assumption on <code>x</code> in the following way.</p><pre><code class="language-julia hljs">@constraints begin 
    q(x, y) = q(x)q(y)
    q(x) = q(x[begin])..q(x[end])
end</code></pre><p>These constraints specifies a mean-field assumption between variables <code>x</code> and <code>y</code> (either single variable or collection of variables) and additionally specifies mean-field assumption on variables <code>x_i</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@constraints</code> macro does not support matrix-based collections of variables. E.g. it is not possible to write <code>q(x[begin, begin])..q(x[end, end])</code></p></div></div><p>It is possible to write more complex factorisation constraints, for example:</p><pre><code class="language-julia hljs">@constraints begin 
    q(x, y) = q(x[begin], y[begin])..q(x[end], y[end])
end</code></pre><p>Specifies a mean-field assumption between collection of variables named <code>x</code> and <code>y</code> only for variables with different indices. Another example is</p><pre><code class="language-julia hljs">@constraints function make_constraints(k)
    q(x) = q(x[begin:k])q(x[k+1:end])
end</code></pre><p>In this example we specify a mean-field assumption between a set of variables <code>x[begin:k]</code> and <code>x[k+1:end]</code>. </p><p>To create a model with extra constraints user may use optional <code>constraints</code> keyword argument for the model function:</p><pre><code class="language-julia hljs">@model function my_model(arguments...)
   ...
end

constraints = @constraints begin 
    ...
end

model, (x, y) = model_name(arguments..., constraints = constraints)</code></pre><p>For more information about factorisation constraints we refer the reader to the <code>ReactiveMP.jl</code> documentation.</p><h2 id="user-guide-meta-specification"><a class="docs-heading-anchor" href="#user-guide-meta-specification">Meta specification</a><a id="user-guide-meta-specification-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-meta-specification" title="Permalink"></a></h2><p>Some nodes in <code>ReactiveMP.jl</code> accept optional meta structure that may be used to change or customise the inference procedure. As an example <code>GCV</code> node accepts the approxximation method that will be used to approximate non-conjugate relationships between variables in this node. <code>GraphPPL.jl</code> exports <code>@meta</code> macro to specify node-specific meta information. For example:</p><pre><code class="language-julia hljs">meta = @meta begin 
    GCV(x, k, w) -&gt; GCVMetadata(GaussHermiteCubature(20))
end</code></pre><p>indicates, that for every <code>GCV</code> node in the model that has <code>x</code>, <code>k</code> and <code>w</code> as connected variables the <code>GCVMetadata(GaussHermiteCubature(20))</code> meta object should be used.</p><p><code>@meta</code> accepts function expression in the same way as <code>@constraints</code> macro, e.g:</p><pre><code class="language-julia hljs">@meta make_meta(n)
    GCV(x, k, w) -&gt; GCVMetadata(GaussHermiteCubature(n))
end

meta = make_meta(20)</code></pre><p>To create a model with extra meta options user may use optional <code>meta</code> keyword argument for the model function:</p><pre><code class="language-julia hljs">@model function my_model(arguments...)
   ...
end

meta = @meta begin 
    ...
end

model, (x, y) = model_name(arguments..., meta = meta)</code></pre><p>For more information about the meta specification we refer the reader to the <code>ReactiveMP.jl</code> documentation.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../utils/">Utils »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 16 May 2023 09:51">Tuesday 16 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

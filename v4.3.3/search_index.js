var documenterSearchIndex = {"docs":
[{"location":"developers_guide/#Developers-guide","page":"Developers Guide","title":"Developers guide","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"This page is aimed at developers of inference backends who aim to integrate GraphPPL into their packages. GraphPPL uses the MetaGraphsNext package to represent a factor graph model as a graph. In GraphPPL, both variables and factors are represented by nodes, and the edges denote the inclusion of variables in factors.","category":"page"},{"location":"developers_guide/#Model-Creation","page":"Developers Guide","title":"Model Creation","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"A model in GraphPPL is represented by the GraphPPL.Model structure.","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL.Model","category":"page"},{"location":"developers_guide/#GraphPPL.Model","page":"Developers Guide","title":"GraphPPL.Model","text":"Model(graph::MetaGraph)\n\nA structure representing a probabilistic graphical model. It contains a MetaGraph object representing the factor graph and a Base.RefValue{Int64} object to keep track of the number of nodes in the graph.\n\nFields:\n\ngraph: A MetaGraph object representing the factor graph.\nplugins: A PluginsCollection object representing the plugins enabled in the model.\nbackend: A Backend object representing the backend used in the model.\ncounter: A Base.RefValue{Int64} object keeping track of the number of nodes in the graph.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"Any model is a bipartite graph of variable and factor nodes, with edges denoting which variables are used in which factors. Models can be indexed with GraphPPL.NodeLabel structures, which is a unique identifier of every variable and factor node composed of its name and a global counter. Every GraphPPL.NodeLabel points to a GraphPPL.NodeData, which contains all relevant information to do Bethe Free Energy minimization in the factor graph. Edges in the graph can be accessed by querying the model with a NodeLabel pair of an edge that exists. Note that both variable and factor nodes are represented by GraphPPL.NodeData structures. To retrieve whether or not a node is a variable or a factor, we can use the is_variable and is_factor functions:","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL.is_variable\nGraphPPL.is_factor","category":"page"},{"location":"developers_guide/#GraphPPL.is_variable","page":"Developers Guide","title":"GraphPPL.is_variable","text":"is_variable(nodedata::NodeData)\n\nReturns true if the node data is associated with a variable node, false otherwise. See also: is_factor,\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.is_factor","page":"Developers Guide","title":"GraphPPL.is_factor","text":"is_factor(nodedata::NodeData)\n\nReturns true if the node data is associated with a factor node, false otherwise. See also: is_variable,\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#Contexts,-Submodels-and-retrieving-NodeLabels","page":"Developers Guide","title":"Contexts, Submodels and retrieving NodeLabels","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"After creating a GraphPPL.Model structure, it is important to know about the attached Context. The Context structure contains all variable and factor nodes in the scope of the model, and contains a Context stucture for all submodels. The context of a model can be accessed by the GraphPPL.getcontext() function:","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL.getcontext","category":"page"},{"location":"developers_guide/#GraphPPL.getcontext","page":"Developers Guide","title":"GraphPPL.getcontext","text":"getcontext(model::Model)\n\nRetrieves the context of a model. The context of a model contains the complete hierarchy of variables and factor nodes.  Additionally, contains all child submodels and their respective contexts. The Context supplies a mapping from symbols to GraphPPL.NodeLabel structures with which the model can be queried.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"Contexts can be accessed like dictionaries, and will point to NodeLabel structures that can be used to query the graph. As a variable with the same name can also live in submodels, we nest the Context structures in the same hierarchy as the submodels themselves. Variables can be retrieved from the Context using a Symbol, whereas factors and submodels can be retrieved with their type and index. For example, to access the first Normal factor in the context, we can use the following syntax:","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"using GraphPPL # hide\nusing Distributions # hide\nimport GraphPPL: @model, create_model, getcontext # hide\n@model function test_model() # hide\n    x ~ Normal(0, 1) # hide\nend # hide\nmodel = create_model(test_model()) # hide\ncontext = getcontext(model) # hide\n\ncontext[Normal, 1]","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"Because on any level, submodels are treated as factors, we can also access submodels in the same way. For example, to access the Normal factor in the first submodel, we can use the following syntax:","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"context[submodel_name, 1][Normal, 1]","category":"page"},{"location":"developers_guide/#Variable-Creation","page":"Developers Guide","title":"Variable Creation","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"Variables in the graph can be created by the GraphPPL.getorcreate! function, that takes the model, the context, the name and the index of the variable, as well as node creation options (such as additional information that should be saved in nodes).","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL.getorcreate!","category":"page"},{"location":"developers_guide/#GraphPPL.getorcreate!","page":"Developers Guide","title":"GraphPPL.getorcreate!","text":"getorcreate!(model::Model, context::Context, options::NodeCreationOptions, name, index)\n\nGet or create a variable (name) from a factor graph model and context, using an index if provided.\n\nThis function searches for a variable (name) in the factor graph model and context specified by the arguments model and context. If the variable exists,  it returns it. Otherwise, it creates a new variable and returns it.\n\nArguments\n\nmodel::Model: The factor graph model to search for or create the variable in.\ncontext::Context: The context to search for or create the variable in.\noptions::NodeCreationOptions: Options for creating the variable. Must be a NodeCreationOptions object.\nname: The variable (name) to search for or create. Must be a symbol.\nindex: Optional index for the variable. Can be an integer, a collection of integers, or nothing. If the index is nothing creates a single variable. \n\nIf the index is an integer creates a vector-like variable. If the index is a collection of integers creates a tensor-like variable.\n\nReturns\n\nThe variable (name) found or created in the factor graph model and context.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#Model-macro","page":"Developers Guide","title":"Model macro","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"The GraphPPL.jl does not export the @model macro by default. For interactive usages (e.g. testing or plotting) GraphPPL.jl implements GraphPPL.DefaultBackend, but any downstream packages must define their own @model macro and implement their custom backend. ","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"import GraphPPL: @model","category":"page"},{"location":"developers_guide/#Piecing-everying-together","page":"Developers Guide","title":"Piecing everying together","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"In this section we will create a factor graph from scratch, materializing the underlying factor graph and applying constraints. First, let's define a model, we'll use the gcv model from the Nested Models section:","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"using GraphPPL, Distributions\n\n@model function gcv(κ, ω, z, x, y)\n    log_σ := κ * z + ω\n    σ := exp(log_σ)\n    y ~ Normal(x, σ)\nend","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"Let's also define a mean-field constraint around the Normal node:","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"constraints = @constraints begin\n    q(x, y, σ) = q(x)q(y)q(σ)\nend","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"This defines the gcv submodel, but now we have to materialize this model. Let's greate a model and hook up all interfaces to variables that will later have to be supplied by the user.","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL.create_model","category":"page"},{"location":"developers_guide/#GraphPPL.create_model","page":"Developers Guide","title":"GraphPPL.create_model","text":"create_model([callback], generator::ModelGenerator)\n\nCreate a model from the ModelGenerator. Accepts an optional callback that can be used to inject extra keyword arguments into the model creation process by downstream packages. For example:\n\nusing GraphPPL, Distributions\n\nGraphPPL.@model function beta_bernoulli(y, a, b)\n    θ ~ Beta(a, b)\n    for i in eachindex(y)\n        y[i] ~ Bernoulli(θ)\n    end\nend\n\ndata_for_y = rand(Bernoulli(0.5), 100)\n\nmodel = GraphPPL.create_model(beta_bernoulli(a = 1, b = 1)) do model, ctx \n    # Inject the data into the model\n    y = GraphPPL.datalabel(model, ctx, GraphPPL.NodeCreationOptions(kind = GraphPPL.VariableKindData), :y, data_for_y)\n    return (; y = y, )\nend\n\nmodel isa GraphPPL.Model\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"model = GraphPPL.create_model(GraphPPL.with_plugins(gcv(), GraphPPL.PluginsCollection(GraphPPL.VariationalConstraintsPlugin(constraints)))) do model, context\n    return (;\n        κ = GraphPPL.getorcreate!(model, context, GraphPPL.NodeCreationOptions(kind = :data, factorized = true), :κ, nothing),\n        ω = GraphPPL.getorcreate!(model, context, GraphPPL.NodeCreationOptions(kind = :data, factorized = true), :ω, nothing),\n        z = GraphPPL.getorcreate!(model, context, GraphPPL.NodeCreationOptions(kind = :data, factorized = true), :z, nothing),\n        x = GraphPPL.getorcreate!(model, context, GraphPPL.NodeCreationOptions(kind = :data, factorized = true), :x, nothing),\n        y = GraphPPL.getorcreate!(model, context, GraphPPL.NodeCreationOptions(kind = :data, factorized = true), :y, nothing)\n    )\nend;","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"Now we have a fully materialized model that can be passed to an inference engine. Factorization constraints are saved in two ways: as a tuple of lists of indices of interfaces that represent the individual clusters (e.g. ([1], [2, 3])) and as a BoundedBitSetTuple. The BoundedBitSetTuple is a more efficient way to store the factorization constraints, which stores a BitMatrix under the hood representing the factorization clusters. Both can be accessed by the GraphPPL.getextra function:","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"context = GraphPPL.getcontext(model)\nnode = context[Normal, 1]\n@show GraphPPL.getextra(model[node], :factorization_constraint_indices)\n@show GraphPPL.getextra(model[node], :factorization_constraint_bitset)\nnothing # hide","category":"page"},{"location":"developers_guide/#ResizableArrays","page":"Developers Guide","title":"ResizableArrays","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL uses ResizableArrays to store arrays of random variables. A ResizableArray is a mutable array that can grow dynamically when data is assigned to it. This is why the x[i] ~ Normal(0, 1) syntax is allowed in GraphPPL; the ResizableArray x will check if i is a valid index and grow the array if necessary. ","category":"page"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL.ResizableArray","category":"page"},{"location":"developers_guide/#GraphPPL.ResizableArray","page":"Developers Guide","title":"GraphPPL.ResizableArray","text":"ResizableArray{T, V, N} <: AbstractArray{T, N}\n\nA ResizableArray is an array that can grow in any dimension. It handles like a regular AbstractArray when calling getindex, but for setindex!  it will automatically resize the array if the index is out of bounds. It is also possible to iterate over the array in the same way as for a regular array. The data is stored internally as a recursive vector. The depth of the recursion is fixed at construction time and cannot be changed. \n\nConstructor\n\nResizableArray(::Type{T}): Create an empty resizable array of type T with depth 1, similar to a vector.\nResizableArray(::Type{T}, ::Val{N}): Create an empty resizable array of type T with depth N, similar to AbstractArray{T, N}.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"ResizableArray is a subtype of AbstractArray, and implements all the functions that are expected from an array. Note that size returns the largest size of the array across each dimension, so an array of size (2, 3) does not necessarily has to have an element stored at index (2, 3), instead there exists a vector of length 3 along the second dimension.","category":"page"},{"location":"developers_guide/#Model-creation-engine-internal","page":"Developers Guide","title":"Model creation engine internal","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL.Context\nGraphPPL.ModelGenerator\nGraphPPL.FactorID\nGraphPPL.NodeData\nGraphPPL.NodeLabel\nGraphPPL.EdgeLabel\nGraphPPL.ProxyLabel\nGraphPPL.indexed_last\nGraphPPL.lift_index\nGraphPPL.datalabel\nGraphPPL.StaticInterfaces\nGraphPPL.VariableRef\nGraphPPL.makevarref\nGraphPPL.MissingCollection\nGraphPPL.VariableNodeProperties\nGraphPPL.FactorNodeProperties\nGraphPPL.VarDict\nGraphPPL.AnonymousVariable\nGraphPPL.NodeDataExtraKey\nGraphPPL.IndexedVariable\n\nGraphPPL.VariableKindRandom\nGraphPPL.VariableKindData\nGraphPPL.VariableKindConstant\nGraphPPL.VariableKindUnknown\n\nGraphPPL.Deterministic\nGraphPPL.Stochastic\nGraphPPL.Atomic\nGraphPPL.Composite\nGraphPPL.NodeCreationOptions\n\nGraphPPL.variable_nodes\nGraphPPL.factor_nodes\nGraphPPL.missing_interfaces\n\nGraphPPL.hasextra\nGraphPPL.getextra\nGraphPPL.setextra!\n\nGraphPPL.make_node!\nGraphPPL.add_atomic_factor_node!\nGraphPPL.add_toplevel_model!\nGraphPPL.add_variable_node!\nGraphPPL.add_composite_factor_node!\nGraphPPL.copy_markov_blanket_to_child_context\nGraphPPL.generate_nodelabel\n\nGraphPPL.FunctionalIndex\nGraphPPL.FunctionalRange","category":"page"},{"location":"developers_guide/#GraphPPL.Context","page":"Developers Guide","title":"GraphPPL.Context","text":"Context\n\nContains all information about a submodel in a probabilistic graphical model.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.ModelGenerator","page":"Developers Guide","title":"GraphPPL.ModelGenerator","text":"ModelGenerator(model, kwargs, plugins)\n\nThe ModelGenerator structure is used to lazily create  the model with the given model and kwargs and plugins.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.FactorID","page":"Developers Guide","title":"GraphPPL.FactorID","text":"FactorID(fform, index)\n\nA unique identifier for a factor node in a probabilistic graphical model.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.NodeData","page":"Developers Guide","title":"GraphPPL.NodeData","text":"NodeData(context, properties, plugins)\n\nData associated with a node in a probabilistic graphical model.  The context field stores the context of the node.  The properties field stores the properties of the node.  The plugins field stores additional properties of the node depending on which plugins were enabled.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.NodeLabel","page":"Developers Guide","title":"GraphPPL.NodeLabel","text":"NodeLabel(name, global_counter::Int64)\n\nUnique identifier for a node (factor or variable) in a probabilistic graphical model.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.EdgeLabel","page":"Developers Guide","title":"GraphPPL.EdgeLabel","text":"EdgeLabel(symbol, index)\n\nA unique identifier for an edge in a probabilistic graphical model.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.ProxyLabel","page":"Developers Guide","title":"GraphPPL.ProxyLabel","text":"ProxyLabel(name, index, proxied)\n\nA label that proxies another label in a probabilistic graphical model.  The proxied objects must implement the is_proxied(::Type) = True(). The proxy labels may spawn new variables in a model, if maycreate is set to True().\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.indexed_last","page":"Developers Guide","title":"GraphPPL.indexed_last","text":"Similar to Base.last when applied on ProxyLabel, but also applies checked_getindex while unrolling\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.lift_index","page":"Developers Guide","title":"GraphPPL.lift_index","text":"The lift_index function \"lifts\" (or tracks) the index that is going to be used to determine the shape of the container upon creation for a variable during the unrolling of the ProxyLabel. This index is used only if the container is set to be created and is not used if  variable container already exists.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.datalabel","page":"Developers Guide","title":"GraphPPL.datalabel","text":"datalabel(model, context, options, name, collection = MissingCollection())\n\nA function for creating proxy data labels to pass into the model upon creation.  Can be useful in combination with ModelGenerator and create_model.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.StaticInterfaces","page":"Developers Guide","title":"GraphPPL.StaticInterfaces","text":"A structure that holds interfaces of a node in the type argument I. Used for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.VariableRef","page":"Developers Guide","title":"GraphPPL.VariableRef","text":"VariableRef(model::Model, context::Context, name::Symbol, index, external_collection = nothing)\n\nVariableRef implements a lazy reference to a variable in the model.  The reference does not create an actual variable in the model immediatelly, but postpones the creation  until strictly necessarily, which is hapenning inside the unroll function. The postponed creation allows users to define  pass a single variable into a submodel, e.g. y ~ submodel(x = x), but use it as an array inside the submodel,  e.g. y[i] ~ Normal(x[i], 1.0). \n\nOptionally accepts an external_collection, which defines the upper limit on the shape of the underlying collection. For example, an external collection [ 1, 2, 3 ] can be used both as y ~ ... and y[i] ~ ..., but not as y[i, j] ~ .... By default, the MissingCollection is used for the external_collection, which does not restrict the shape of the underlying collection.\n\nThe index is always a Tuple. By default, (nothing, ) is used, to indicate empty indices with no restrictions on the shape of the underlying collection.  If \"non-nothing\" index is supplied, e.g. (1, ) the shape of the udnerlying collection will be fixed to match the index  (1-dimensional in case of (1, ), 2-dimensional in case of (1, 1) and so on).\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.makevarref","page":"Developers Guide","title":"GraphPPL.makevarref","text":"makevarref(fform::F, model::Model, context::Context, options::NodeCreationOptions, name::Symbol, index::Tuple)\n\nA function that creates VariableRef, but takes the fform into account. When fform happens to be Atomic creates  the underlying variable immediatelly without postponing. When fform is Composite does not create the actual variable,  but waits until strictly necessarily.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.MissingCollection","page":"Developers Guide","title":"GraphPPL.MissingCollection","text":"A placeholder collection for VariableRef when the actual external collection is not yet available.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.VariableNodeProperties","page":"Developers Guide","title":"GraphPPL.VariableNodeProperties","text":"VariableNodeProperties(name, index, kind, link, value)\n\nData associated with a variable node in a probabilistic graphical model.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.FactorNodeProperties","page":"Developers Guide","title":"GraphPPL.FactorNodeProperties","text":"FactorNodeProperties(fform, neighbours)\n\nData associated with a factor node in a probabilistic graphical model.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.VarDict","page":"Developers Guide","title":"GraphPPL.VarDict","text":"VarDict\n\nA recursive dictionary structure that contains all variables in a probabilistic graphical model. Iterates over all variables in the model and their children in a linear fashion, but preserves the recursive nature of the actual model.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.AnonymousVariable","page":"Developers Guide","title":"GraphPPL.AnonymousVariable","text":"AnonymousVariable(model, context)\n\nDefines a lazy structure for anonymous variables. The actual anonymous variables materialize only in make_node! upon calling, because it needs arguments to the make_node! in order to create proper links.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.NodeDataExtraKey","page":"Developers Guide","title":"GraphPPL.NodeDataExtraKey","text":"A compile time key to access the extra properties of the NodeData structure.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.IndexedVariable","page":"Developers Guide","title":"GraphPPL.IndexedVariable","text":"IndexedVariable(name, index)\n\nIndexedVariable represents a reference to a variable named name with index index. \n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.VariableKindRandom","page":"Developers Guide","title":"GraphPPL.VariableKindRandom","text":"Defines a random (or latent) kind for a variable in a probabilistic graphical model.\n\n\n\n\n\n","category":"constant"},{"location":"developers_guide/#GraphPPL.VariableKindData","page":"Developers Guide","title":"GraphPPL.VariableKindData","text":"Defines a data kind for a variable in a probabilistic graphical model.\n\n\n\n\n\n","category":"constant"},{"location":"developers_guide/#GraphPPL.VariableKindConstant","page":"Developers Guide","title":"GraphPPL.VariableKindConstant","text":"Defines a constant kind for a variable in a probabilistic graphical model.\n\n\n\n\n\n","category":"constant"},{"location":"developers_guide/#GraphPPL.VariableKindUnknown","page":"Developers Guide","title":"GraphPPL.VariableKindUnknown","text":"Placeholder for a variable kind in a probabilistic graphical model.\n\n\n\n\n\n","category":"constant"},{"location":"developers_guide/#GraphPPL.Deterministic","page":"Developers Guide","title":"GraphPPL.Deterministic","text":"Deterministic\n\nDeterministic object used to parametrize factor node object with determinstic type of relationship between variables.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.Stochastic","page":"Developers Guide","title":"GraphPPL.Stochastic","text":"Stochastic\n\nStochastic object used to parametrize factor node object with stochastic type of relationship between variables.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.Atomic","page":"Developers Guide","title":"GraphPPL.Atomic","text":"Atomic\n\nAtomic object used as a trait of structs and functions that are composed of a single node and are therefore materialized as a single node in the factor graph.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.Composite","page":"Developers Guide","title":"GraphPPL.Composite","text":"Composite\n\nComposite object used as a trait of structs and functions that are composed of multiple nodes and therefore implement make_node!.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.NodeCreationOptions","page":"Developers Guide","title":"GraphPPL.NodeCreationOptions","text":"NodeCreationOptions(namedtuple)\n\nOptions for creating a node in a probabilistic graphical model. These are typically coming from the where {} block  in the @model macro, but can also be created manually. Expects a NamedTuple as an input.\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.variable_nodes","page":"Developers Guide","title":"GraphPPL.variable_nodes","text":"A version variable_nodes(model) that uses a callback function to process the variable nodes. The callback function accepts both the label and the node data.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.factor_nodes","page":"Developers Guide","title":"GraphPPL.factor_nodes","text":"A version factor_nodes(model) that uses a callback function to process the factor nodes. The callback function accepts both the label and the node data.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.missing_interfaces","page":"Developers Guide","title":"GraphPPL.missing_interfaces","text":"missing_interfaces(node_type, val, known_interfaces)\n\nReturns the interfaces that are missing for a node. This is used when inferring the interfaces for a node that is composite.\n\nArguments\n\nnode_type: The type of the node as a Function object.\nval: The value of the amount of interfaces the node is supposed to have. This is a Static.StaticInt object.\nknown_interfaces: The known interfaces for the node.\n\nReturns\n\nmissing_interfaces: A Vector of the missing interfaces.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.hasextra","page":"Developers Guide","title":"GraphPPL.hasextra","text":"hasextra(node::NodeData, key::Symbol)\n\nChecks if NodeData has an extra property with the given key.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.getextra","page":"Developers Guide","title":"GraphPPL.getextra","text":"getextra(node::NodeData, key::Symbol, [ default ])\n\nReturns the extra property with the given key. Optionally, if the property does not exist, returns the default value.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.setextra!","page":"Developers Guide","title":"GraphPPL.setextra!","text":"setextra!(node::NodeData, key::Symbol, value)\n\nSets the extra property with the given key to the given value.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.make_node!","page":"Developers Guide","title":"GraphPPL.make_node!","text":"make_node!\n\nMake a new factor node in the Model and specified Context, attach it to the specified interfaces, and return the interface that is on the lhs of the ~ operator.\n\nArguments\n\nmodel::Model: The model to add the node to.\nctx::Context: The context in which to add the node.\nfform: The function that the node represents.\nlhs_interface: The interface that is on the lhs of the ~ operator.\nrhs_interfaces: The interfaces that are the arguments of fform on the rhs of the ~ operator.\n__parent_options__::NamedTuple = nothing: The options to attach to the node.\n__debug__::Bool = false: Whether to attach debug information to the factor node.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.add_atomic_factor_node!","page":"Developers Guide","title":"GraphPPL.add_atomic_factor_node!","text":"add_atomic_factor_node!(model::Model, context::Context, options::NodeCreationOptions, fform)\n\nAdd an atomic factor node to the model with the given name. The function generates a new symbol for the node and adds it to the model with the generated symbol as the key and a FactorNodeData struct.\n\nArgs:     - model::Model: The model to which the node is added.     - context::Context: The context to which the symbol is added.     - options::NodeCreationOptions: The options for the creation process.     - fform::Any: The functional form of the node.\n\nReturns:     - The generated label for the node.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.add_toplevel_model!","page":"Developers Guide","title":"GraphPPL.add_toplevel_model!","text":"Add the fform as the toplevel model to the model and context with the specified interfaces. Calls the postprocess logic for the attached plugins of the model. Should be called only once for a given Model object.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.add_variable_node!","page":"Developers Guide","title":"GraphPPL.add_variable_node!","text":"add_variable_node!(model::Model, context::Context, options::NodeCreationOptions, name::Symbol, index)\n\nAdd a variable node to the model with the given name and index. This function is unsafe (doesn't check if a variable with the given name already exists in the model). \n\nArgs:     - model::Model: The model to which the node is added.     - context::Context: The context to which the symbol is added.     - options::NodeCreationOptions: The options for the creation process.     - name::Symbol: The ID of the variable.     - index: The index of the variable.\n\nReturns:     - The generated symbol for the variable.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.add_composite_factor_node!","page":"Developers Guide","title":"GraphPPL.add_composite_factor_node!","text":"Add a composite factor node to the model with the given name.\n\nThe function generates a new symbol for the node and adds it to the model with the generated symbol as the key and a NodeData struct with is_variable set to false and node_name set to the given name.\n\nArgs:     - model::Model: The model to which the node is added.     - parent_context::Context: The context to which the symbol is added.     - context::Context: The context of the composite factor node.     - node_name::Symbol: The name of the node.\n\nReturns:     - The generated id for the node.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.copy_markov_blanket_to_child_context","page":"Developers Guide","title":"GraphPPL.copy_markov_blanket_to_child_context","text":"copy_markov_blanket_to_child_context(child_context::Context, interfaces::NamedTuple)\n\nCopy the variables in the Markov blanket of a parent context to a child context, using a mapping specified by a named tuple.\n\nThe Markov blanket of a node or model in a Factor Graph is defined as the set of its outgoing interfaces.  This function copies the variables in the Markov blanket of the parent context specified by the named tuple interfaces to the child context child_context,      by setting each child variable in child_context.individual_variables to its corresponding parent variable in interfaces.\n\nArguments\n\nchild_context::Context: The child context to which to copy the Markov blanket variables.\ninterfaces::NamedTuple: A named tuple that maps child variable names to parent variable names.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.generate_nodelabel","page":"Developers Guide","title":"GraphPPL.generate_nodelabel","text":"generate_nodelabel(model::Model, name::Symbol)\n\nGenerate a new NodeLabel object with a unique identifier based on the specified name and the number of nodes already in the model.\n\nArguments:\n\nmodel: A Model object representing the probabilistic graphical model.\nname: A symbol representing the name of the node.\nvariable_type: A UInt8 representing the type of the variable. 0 = factor, 1 = individual variable, 2 = vector variable, 3 = tensor variable\nindex: An integer or tuple of integers representing the index of the variable.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.FunctionalIndex","page":"Developers Guide","title":"GraphPPL.FunctionalIndex","text":"FunctionalIndex\n\nA special type of an index that represents a function that can be used only in pair with a collection.  An example of a FunctionalIndex can be firstindex or lastindex, but more complex use cases are possible too,  e.g. firstindex + 1. Important part of the implementation is that the resulting structure is isbitstype(...) = true,  that allows to store it in parametric type as valtype. One use case for this structure is to dispatch on and to replace begin or end  (or more complex use cases, e.g. begin + 1).\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#GraphPPL.FunctionalRange","page":"Developers Guide","title":"GraphPPL.FunctionalRange","text":"FunctionalRange(left, range)\n\nA range can handle FunctionalIndex as one of (or both) the bounds.\n\njulia> first = GraphPPL.FunctionalIndex{:begin}(firstindex)\n(begin)\n\njulia> last = GraphPPL.FunctionalIndex{:end}(lastindex)\n(end)\n\njulia> range = GraphPPL.FunctionalRange(first + 1, last - 1)\n((begin) + 1):((end) - 1)\n\njulia> [ 1.0, 2.0, 3.0, 4.0 ][range]\n2-element Vector{Float64}:\n 2.0\n 3.0\n\n\n\n\n\n","category":"type"},{"location":"developers_guide/#Model-macro-internals","page":"Developers Guide","title":"Model macro internals","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL.combine_args\nGraphPPL.convert_local_statement\nGraphPPL.add_get_or_create_expression\nGraphPPL.keyword_expressions_to_named_tuple\nGraphPPL.convert_anonymous_variables\nGraphPPL.is_kwargs_expression\nGraphPPL.convert_to_kwargs_expression\nGraphPPL.convert_deterministic_statement\nGraphPPL.proxy_args\nGraphPPL.save_expression_in_tilde\nGraphPPL.convert_meta_object\nGraphPPL.get_boilerplate_functions\nGraphPPL.apply_pipeline_collection\nGraphPPL.convert_tilde_expression\nGraphPPL.check_reserved_variable_names_model\nGraphPPL.generate_get_or_create\nGraphPPL.add_meta_construction\nGraphPPL.apply_pipeline\nGraphPPL.options_vector_to_named_tuple\nGraphPPL.get_created_by\nGraphPPL.convert_to_anonymous","category":"page"},{"location":"developers_guide/#GraphPPL.combine_args","page":"Developers Guide","title":"GraphPPL.combine_args","text":"combine_args(args::Vector, kwargs::Nothing)\n\nCombines a vector of arguments into a single expression.\n\nArguments\n\nargs::Vector: The vector of arguments.\nkwargs::Nothing: The keyword arguments. This argument is always nothing.\n\nReturns\n\nAn Expr with the combined arguments.\n\n\n\n\n\ncombine_args(args::Vector, kwargs::Vector)\n\nCombines a vector of arguments and a vector of keyword arguments into a single expression.\n\nArguments\n\nargs::Vector: The vector of arguments.\nkwargs::Vector: The vector of keyword arguments.\n\nReturns\n\nAn Expr with the combined arguments and keyword arguments.\n\n\n\n\n\ncombine_args(args::Nothing, kwargs::Nothing)\n\nReturns nothing.\n\nArguments\n\nargs::Nothing: The arguments. This argument is always nothing.\nkwargs::Nothing: The keyword arguments. This argument is always nothing.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.convert_local_statement","page":"Developers Guide","title":"GraphPPL.convert_local_statement","text":"convert_local_statement(expr::Expr)\n\nConverts a statement with the local keyword to the creation of an additional variable and the inclusion of thie variable in the subsequent tilde expression.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.add_get_or_create_expression","page":"Developers Guide","title":"GraphPPL.add_get_or_create_expression","text":"add_get_or_create_expression(e::Expr)\n\nAdd code to get or create a variable in the graph. The code generated by this function ensures that the left-hand-side is always defined in the local scope and can be used in make_node! afterwards.\n\nArguments\n\ne::Expr: The expression to modify.\n\nReturns\n\nA quote block with the modified expression.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.keyword_expressions_to_named_tuple","page":"Developers Guide","title":"GraphPPL.keyword_expressions_to_named_tuple","text":"keyword_expressions_to_named_tuple(keywords::Vector)\n\nConverts a vector of keyword expressions to a named tuple.\n\nArguments\n\nkeywords::Vector: The vector of keyword expressions.\n\nReturns\n\nNamedTuple: The named tuple.\n\nExamples\n\njulia> keyword_expressions_to_named_tuple([:($(Expr(:kw, :in1, :y))), :($(Expr(:kw, :in2, :z)))])\n(in1 = y, in2 = z)\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.convert_anonymous_variables","page":"Developers Guide","title":"GraphPPL.convert_anonymous_variables","text":"convert_anonymous_variables(e::Expr)\n\nConvert a function argument in the right-hand side of an expression to an anonymous variable. This function is used to convert function calls in the arguments of node creations to anonymous variables in the graph.\n\nExample\n\n```jldoctest\njulia> convert_anonymous_variables(:(x ~ Normal(μ, sqrt(σ2)) where {created_by=:(Normal(μ, sqrt(σ2)))}))\n:(x ~ (Normal(μ, anon_1 ~ (sqrt(σ2) where {anonymous = true, created_by = :(Normal(μ, sqrt(σ2)))})) where (created_by = :(Normal(μ, sqrt(σ2))))))\n```\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.is_kwargs_expression","page":"Developers Guide","title":"GraphPPL.is_kwargs_expression","text":"is_kwargs_expression(e::Expr)\n\nReturns true if the given expression e is a keyword argument expression, i.e., if its head is either :kw or :parameters.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.convert_to_kwargs_expression","page":"Developers Guide","title":"GraphPPL.convert_to_kwargs_expression","text":"convert_to_kwargs_expression(expr::Expr)\n\nConvert an expression to a keyword argument expression. This function is used in the conversion of tilde and dot-tilde expressions to ensure that the arguments are passed as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.convert_deterministic_statement","page":"Developers Guide","title":"GraphPPL.convert_deterministic_statement","text":"convert_deterministic_statement(expr::Expr)\n\nConvert a deterministic statement to a tilde statement with the is_deterministic option set to true.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.proxy_args","page":"Developers Guide","title":"GraphPPL.proxy_args","text":"Converts an expression into its proxied equivalent. Used to pass variables in sub-models and create a chain of proxied labels.\n\njulia> x = GraphPPL.NodeLabel(:x, 1)\nx_1\njulia> GraphPPL.proxy_args(:(y = x))\n:(y = GraphPPL.proxylabel(:x, x, nothing, GraphPPL.False()))\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.save_expression_in_tilde","page":"Developers Guide","title":"GraphPPL.save_expression_in_tilde","text":"save_expression_in_tilde(expr::Expr)\n\nSave the expression found in the tilde syntax in the created_by field of the expression. This function also ensures that the where clause is always present in the tilde syntax.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.convert_meta_object","page":"Developers Guide","title":"GraphPPL.convert_meta_object","text":"convert_meta_object(e::Expr)\n\nConverts a variable meta or a factor meta call on the left hand side of a meta specification to a GraphPPL.MetaObject.\n\nArguments\n\ne::Expr: The expression to convert.\n\nReturns\n\nExpr: The resulting expression with the variable reference or factor function call converted to a GraphPPL.MetaObject.\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.get_boilerplate_functions","page":"Developers Guide","title":"GraphPPL.get_boilerplate_functions","text":"get_boilerplate_functions(ms_name, ms_args, num_interfaces)\n\nReturns a quote block containing boilerplate functions for a model macro.\n\nArguments\n\nms_name: The name of the model macro.\nms_args: The arguments of the model macro.\nnum_interfaces: The number of interfaces of the model macro.\n\nReturns\n\nquote: A quote block containing the boilerplate functions for the model macro.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.apply_pipeline_collection","page":"Developers Guide","title":"GraphPPL.apply_pipeline_collection","text":"apply_pipeline_collection(e::Expr, collection)\n\nSimilar to apply_pipeline, but applies a collection of pipeline functions to an expression. \n\nArguments\n\ne::Expr: An expression to apply the pipeline to.\ncollection: A collection of functions to apply to the expressions in e.\n\nReturns\n\nThe result of applying the pipeline function to e.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.convert_tilde_expression","page":"Developers Guide","title":"GraphPPL.convert_tilde_expression","text":"convert_tilde_expression(e::Expr)\n\nConverts a tilde expression to a make_node! call. Converts broadcasted tile expressions to make_node! calls with nothing as the lhs to indicate that a variable should be created on every broadcasted pass.\n\nArguments\n\ne::Expr: The expression to convert.\n\nReturns\n\nExpr: The converted expression.\n\nExamples\n\njulia> convert_tilde_expression(:(x ~ Normal(0, 1) where {created_by = (x~Normal(0,1))}))\nquote\n    GraphPPL.make_node!(__model__, __context__, Normal, x, [0, 1]; options = Dict{Any, Any}(:created_by => :(x ~ Normal(0, 1))), debug = debug)\nend\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.check_reserved_variable_names_model","page":"Developers Guide","title":"GraphPPL.check_reserved_variable_names_model","text":"check_reserved_variable_names_model(expr::Expr)\n\nCheck if any of the variable names in the given expression are reserved in the model macro. Reserved variable names are:\n\n__parent_options__\n__debug__\n__model__\n__context__\n__parent_context__\n__lhs_interface__\n__rhs_interfaces__\n__interfaces__\n\nArguments\n\nexpr::Expr: The expression to check for reserved variable names.\n\nExamples\n\njldoctest julia> check_reserved_variable_names_model(:(__parent_options__ ~ Normal(μ, σ)) ERROR: Variable name in __parent_options__ ~ Normal(μ, σ) cannot be used as it is a reserved variable name in the model macro.`\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.generate_get_or_create","page":"Developers Guide","title":"GraphPPL.generate_get_or_create","text":"generate_get_or_create(s::Symbol, lhs::Symbol, index::Nothing)\n\nGenerates code to get or create a variable in the graph. This function is used to generate code for variables that are not indexed.\n\nArguments\n\ns::Symbol: The symbol representing the variable.\nindex::Nothing: The index of the variable. This argument is always nothing.\n\nReturns\n\nA quote block with the code to get or create the variable in the graph.\n\n\n\n\n\ngenerate_get_or_create(s::Symbol, lhs::Expr, index::AbstractArray)\n\nGenerates code to get or create a variable in the graph. This function is used to generate code for variables that are indexed.\n\nArguments\n\ns::Symbol: The symbol representing the variable.\nindex::AbstractArray: The index of the variable.\n\nReturns\n\nA quote block with the code to get or create the variable in the graph.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.add_meta_construction","page":"Developers Guide","title":"GraphPPL.add_meta_construction","text":"add_meta_construction(e::Expr)\n\nAdd a meta construction to the given expression e. This function creates a new GraphPPL.MetaSpecification object and assigns it to the __meta__ variable. It then evaluates the given expression e in the context of this new GraphPPL.MetaSpecification object, and returns the resulting GraphPPL.MetaSpecification object.\n\nArguments\n\ne::Expr: The expression to evaluate in the context of the new GraphPPL.MetaSpecification object.\n\nReturns\n\ne::Expr: The expression that will generate the GraphPPL.MetaSpecification object.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.apply_pipeline","page":"Developers Guide","title":"GraphPPL.apply_pipeline","text":"apply_pipeline(e::Expr, pipeline)\n\nApply a pipeline function to an expression.\n\nThe apply_pipeline function takes an expression e and a pipeline function and applies the function in the pipeline to e when walking over it. The walk utilized can be specified by implementing what_walk for a pipeline funciton.\n\nArguments\n\ne::Expr: An expression to apply the pipeline to.\npipeline: A function to apply to the expressions in e.\n\nReturns\n\nThe result of applying the pipeline function to e.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.options_vector_to_named_tuple","page":"Developers Guide","title":"GraphPPL.options_vector_to_named_tuple","text":"options_vector_to_named_tuple(options::AbstractArray)\n\nConverts the array found by pattern matching on the where clause in a tilde expression into a named tuple.\n\nArguments\n\noptions::AbstractArray: An array of options.\n\nReturns\n\nresult: A named tuple of options.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.get_created_by","page":"Developers Guide","title":"GraphPPL.get_created_by","text":"get_created_by(options::AbstractArray)\n\nRetrieve the created_by option from the given options. Expects the options to be retrieved using the MacroTools.@capture macro.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#GraphPPL.convert_to_anonymous","page":"Developers Guide","title":"GraphPPL.convert_to_anonymous","text":"convert_to_anonymous(e::Expr, created_by)\n\nConvert an expression to an anonymous variable. This function is used to convert function calls in the arguments of node creations to anonymous variables in the graph.\n\n\n\n\n\n","category":"function"},{"location":"developers_guide/#Auxiliary-functionality","page":"Developers Guide","title":"Auxiliary functionality","text":"","category":"section"},{"location":"developers_guide/","page":"Developers Guide","title":"Developers Guide","text":"GraphPPL.prune!","category":"page"},{"location":"developers_guide/#GraphPPL.prune!","page":"Developers Guide","title":"GraphPPL.prune!","text":"prune!(m::Model)\n\nRemove all nodes from the model that are not connected to any other node.\n\n\n\n\n\n","category":"function"},{"location":"plugins/constraint_specification/#constraints-specification","page":"Variational Inference & Constraints","title":"Constraint Specification","text":"","category":"section"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"GraphPPL represents your probabilistic model and as a Bethe Free Energy (BFE), which means that users can define constraints on the variational posterior that influence the inference procedure. The BFE is chosen as the objective function because it is a generalization of many well-known inference algorithms. In this section we will explain how to specify constraints on the variational posterior. There are two major types of constraints we can apply: We can apply factorization constraints to factor nodes, which specify how the variational posterior factorizes around a factor node. We can also apply functional form constraints to variable nodes, which specify the functional form of the variational posterior that a variable takes. We can specify all constraints using the @constraints macro.","category":"page"},{"location":"plugins/constraint_specification/#The-constraints-macro","page":"Variational Inference & Constraints","title":"The constraints macro","text":"","category":"section"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"The constraints macro accepts a high-level constraint specification and converts this to a structure that can be interpreted by GraphPPL models. For example, suppose we have the following toy model, that defines a Gaussian distribution over x with mean y and variance z:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"using GraphPPL\nusing Distributions\nimport GraphPPL: @model\n\n@model function toy_model(x, y, z)\n    x ~ Normal(y, z)\nend","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"Suppose we want to apply the following constraints over the variational posterior q:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"q(x y z) = q(x y)q(z) \nq(x) sim Normal","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"We can write this in the constraints macro using the following code:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"@constraints begin\n    q(x, y, z) = q(x, y)q(z)\n    q(x) :: Normal\nend","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"We can reference variables in the constraints macro with their corresponding name in the model specification. Naturally, this raises the question on how we can specify constraints over variables in submodels, as these variables are not available in the scope of the model specification. To this extent, we can nest our constraints in the same way in which we have nested our models, and use the for q in submodel block to specify constraints over submodels. For example, suppose we have the following model:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"@model function toy_model(x, y, z)\n    x ~ Normal(y, z)\n    y ~ Normal(0, 1)\nend\n\n@model function outer_toy_model(a, b, c)\n    a ~ toy_model(y = b, z = c)\nend","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"We can specify constraints over the toy_model submodel using the following code:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"@constraints begin\n    for q in toy_model\n        q(x, y, z) = q(x, y)q(z)\n        q(x) :: Normal\n    end\nend","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"The submodel constraint specification applies to all submodels with the same name. However, as a user you might want to specify constraints over a specific submodel. To this extent, we can use the for q in (submodel, index) syntax. This will only apply the constraints to the submodel with the corresponding index. For example, suppose we have the following model:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"@model function toy_model(x, y, z)\n    x ~ Normal(y, z)\n    y ~ Normal(0, 1)\nend\n\n@model function outer_toy_model(a, b, c)\n    a ~ toy_model(y = b, z = c)\n    a ~ toy_model(y = b, z = c)\nend","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"We can specify constraints over the first toy_model submodel using the following code:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"@constraints begin\n    for q in (toy_model, 1)\n        q(x, y, z) = q(x, y)q(z)\n        q(x) :: Normal\n    end\nend","category":"page"},{"location":"plugins/constraint_specification/#Stacked-functional-form-constraints","page":"Variational Inference & Constraints","title":"Stacked functional form constraints","text":"","category":"section"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"In the constraints macro, we can specify multiple functional form constraints over the same variable. For example, suppose we have the following model:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"@constraints begin \n    q(x) :: Normal :: Beta\nend","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"In this constraint the posterior over x will first be constrained to be a normal distribution, and then the result with be constrained to be a beta distribution. This might be useful to create a chain of constraints that are applied in order. The resulting constraint is a tuple of constraints.","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"note: Note\nThe inference backend must support stacked constraints for this feature to work. Some combinations of stacked constraints might not be supported or theoretically sound.","category":"page"},{"location":"plugins/constraint_specification/#Default-constraints","page":"Variational Inference & Constraints","title":"Default constraints","text":"","category":"section"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"While we can specify constraints over all instances of a submodel at a specific layer of the hierarchy, we're not guaranteed to have all instances of a submodel at a specific layer of the hierarchy. To this extent, we can specify default constraints that apply to all instances of a specific submodel. For example, we can define the following model, where we have a recursive_model instance at every layer of the hierarchy:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"@model function recursive_model(n, x, y)\n    z ~ Gamma(1, 1)\n    if n > 0\n        y ~ Normal(recursive_model(n = n - 1, x = x), z)\n    else\n        y ~ Normal(0, z)\n    end\nend","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"We can specify default constraints over the recursive_model submodel using the following code:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"GraphPPL.default_constraints(::typeof(recursive_model)) = @constraints begin\n    q(x, y, z) = q(x)q(y)q(z)\nend","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"When a model of type recursive_model is now created, the default constraints will be applied to all instances of the recursive_model submodel. Note that default constraints are overwritten by constraints passed to the top-level model, if they concern the same instance of a submodel.","category":"page"},{"location":"plugins/constraint_specification/#Prespecified-constraints","page":"Variational Inference & Constraints","title":"Prespecified constraints","text":"","category":"section"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"GraphPPL provides a set of prespecified constraints that can be used to specify constraints over the variational posterior. These constraint sets are aliases for their corresponding equivalent constriant sets, and can be used for convenience. The following prespecified constraints are available:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"GraphPPL.MeanField\nGraphPPL.BetheFactorization","category":"page"},{"location":"plugins/constraint_specification/#GraphPPL.MeanField","page":"Variational Inference & Constraints","title":"GraphPPL.MeanField","text":"MeanField\n\nGeneric factorisation constraint used to specify a mean-field factorisation for recognition distribution q. This constraint ignores default_constraints from submodels and forces everything to be factorized.\n\nSee also: BetheFactorization\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.BetheFactorization","page":"Variational Inference & Constraints","title":"GraphPPL.BetheFactorization","text":"BetheFactorization\n\nGeneric factorisation constraint used to specify the Bethe factorisation for recognition distribution q. An alias to UnspecifiedConstraints.\n\nSee also: MeanField\n\n\n\n\n\n","category":"function"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"This means that we can write the following:","category":"page"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"@constraints begin\n    q(x, y, z) = MeanField() # Equivalent to q(x, y, z) = q(x)q(y)q(z)\n    q(a, b, c) = BetheFactorization() # Equivalent to q(a, b, c) = q(a, b, c), can be used to overwrite default constraints.\nend","category":"page"},{"location":"plugins/constraint_specification/#Plugin's-internals","page":"Variational Inference & Constraints","title":"Plugin's internals","text":"","category":"section"},{"location":"plugins/constraint_specification/","page":"Variational Inference & Constraints","title":"Variational Inference & Constraints","text":"GraphPPL.VariationalConstraintsPlugin\nGraphPPL.Constraints\nGraphPPL.SpecificSubModelConstraints\nGraphPPL.GeneralSubModelConstraints\nGraphPPL.FactorizationConstraint\nGraphPPL.FactorizationConstraintEntry\n\nGraphPPL.MarginalFormConstraint\nGraphPPL.MessageFormConstraint\n\nGraphPPL.materialize_constraints!\nGraphPPL.factorization_split\n\nGraphPPL.SplittedRange\nGraphPPL.CombinedRange","category":"page"},{"location":"plugins/constraint_specification/#GraphPPL.VariationalConstraintsPlugin","page":"Variational Inference & Constraints","title":"GraphPPL.VariationalConstraintsPlugin","text":"VariationalConstraintsPlugin(constraints)\n\nA plugin that adds a VI related properties to the factor node for the variational inference procedure.\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.Constraints","page":"Variational Inference & Constraints","title":"GraphPPL.Constraints","text":"Constraints\n\nAn instance of Constraints represents a set of constraints to be applied to a variational posterior in a factor graph model.\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.SpecificSubModelConstraints","page":"Variational Inference & Constraints","title":"GraphPPL.SpecificSubModelConstraints","text":"SpecificSubModelConstraints\n\nA SpecificSubModelConstraints represents a set of constraints to be applied to a specific submodel. The submodel is specified by the tag field, which contains the identifier of the submodel. \n\nSee also: GraphPPL.GeneralSubModelConstraints\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.GeneralSubModelConstraints","page":"Variational Inference & Constraints","title":"GraphPPL.GeneralSubModelConstraints","text":"GeneralSubModelConstraints\n\nA GeneralSubModelConstraints represents a set of constraints to be applied to a set of submodels. The submodels are specified by the fform field, which contains the identifier of the submodel.  The constraints field contains the constraints to be applied to all instances of this submodel on this level in the model hierarchy.\n\nSee also: GraphPPL.SpecificSubModelConstraints\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.FactorizationConstraint","page":"Variational Inference & Constraints","title":"GraphPPL.FactorizationConstraint","text":"FactorizationConstraint{V, F}\n\nA FactorizationConstraint represents a single factorization constraint in a variational posterior constraint specification. We use type parametrization  to dispatch on different types of constraints, for example q(x, y) = MeanField() is treated different from q(x, y) = q(x)q(y). \n\nThe FactorizationConstraint constructor checks for obvious errors, such as duplicate variables in the constraint specification and checks if the left hand side and right hand side contain the same variables.\n\nSee also: [`GraphPPL.FactorizationConstraintEntry`](@ref)\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.FactorizationConstraintEntry","page":"Variational Inference & Constraints","title":"GraphPPL.FactorizationConstraintEntry","text":"FactorizationConstraintEntry\n\nA FactorizationConstraintEntry is a group of variables (represented as a Vector of IndexedVariable objects) that represents a factor group in a factorization constraint.\n\nSee also: GraphPPL.FactorizationConstraint\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.MarginalFormConstraint","page":"Variational Inference & Constraints","title":"GraphPPL.MarginalFormConstraint","text":"A MarginalFormConstraint represents a single functional form constraint in a variational marginal constraint specification. We use type parametrization to dispatch on different types of constraints, for example q(x, y) :: MvNormal should be treated different from q(x) :: Normal.\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.MessageFormConstraint","page":"Variational Inference & Constraints","title":"GraphPPL.MessageFormConstraint","text":"A MessageConstraint represents a single constraint on the messages in a message passing schema.  These constraints closely resemble the MarginalFormConstraint but are used to specify constraints on the messages in a message passing schema.\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.materialize_constraints!","page":"Variational Inference & Constraints","title":"GraphPPL.materialize_constraints!","text":"materialize_constraints!(model::Model, node_label::NodeLabel, node_data::NodeData)\n\nMaterializes the factorization constraint in node_data in model at node_label.  This function converts the BitSet representation of a constraint in node_data to the tuple representation containing all interface names.\n\n\n\n\n\n","category":"function"},{"location":"plugins/constraint_specification/#GraphPPL.factorization_split","page":"Variational Inference & Constraints","title":"GraphPPL.factorization_split","text":"factorization_split(left, right)\n\nCreates a new FactorizationConstraintEntry that contains a SplittedRange splitting left and right.  This function is used to convert two FactorizationConstraintEntrys (for example q(x[begin])..q(x[end])) into a single FactorizationConstraintEntry containing the SplittedRange.\n\nSee also: [`GraphPPL.SplittedRange`](@ref)\n\n\n\n\n\n","category":"function"},{"location":"plugins/constraint_specification/#GraphPPL.SplittedRange","page":"Variational Inference & Constraints","title":"GraphPPL.SplittedRange","text":"SplittedRange{L, R}\n\nSplittedRange represents a range of splitted variable in factorization specification language. Such variables specified to be not in the same factorization cluster.\n\nSee also: GraphPPL.CombinedRange\n\n\n\n\n\n","category":"type"},{"location":"plugins/constraint_specification/#GraphPPL.CombinedRange","page":"Variational Inference & Constraints","title":"GraphPPL.CombinedRange","text":"CombinedRange{L, R}\n\nCombinedRange represents a range of combined variable in factorization specification language. Such variables specified to be in the same factorization cluster.\n\nSee also: GraphPPL.SplittedRange\n\n\n\n\n\n","category":"type"},{"location":"plugins/node_id/#plugins-node-id","page":"Setting ID of nodes","title":"Node ID plugin","text":"","category":"section"},{"location":"plugins/node_id/","page":"Setting ID of nodes","title":"Setting ID of nodes","text":"GraphPPL provides a built-in plugin to mark factor nodes with a specific ID for later analysis or debugging purposes.","category":"page"},{"location":"plugins/node_id/","page":"Setting ID of nodes","title":"Setting ID of nodes","text":"GraphPPL.NodeIdPlugin","category":"page"},{"location":"plugins/node_id/#GraphPPL.NodeIdPlugin","page":"Setting ID of nodes","title":"GraphPPL.NodeIdPlugin","text":"NodeIdPlugin\n\nA plugin that adds an id property to the factor node. This field can be used to find a node given its id with the GraphPPL.by_nodeid filter.\n\n\n\n\n\n","category":"type"},{"location":"plugins/node_id/","page":"Setting ID of nodes","title":"Setting ID of nodes","text":"The plugin allows to specify the id in the where { ... } block during the node construction. Here how it works:","category":"page"},{"location":"plugins/node_id/","page":"Setting ID of nodes","title":"Setting ID of nodes","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function submodel(y, x, z)\n    y ~ Normal(x, z) where { id = \"from submodel\" }\nend\n\n@model function mainmodel() \n    x ~ Normal(0.0, 1.0)\n    z ~ Normal(0.0, 1.0)\n    y ~ submodel(x = x, z = z)\nend","category":"page"},{"location":"plugins/node_id/","page":"Setting ID of nodes","title":"Setting ID of nodes","text":"In this example we have created three Normal factor nodes and would like to access the one which has been created within the submodel. To do that, we need to instantiate our model with the GraphPPL.NodeIdPlugin plugin.","category":"page"},{"location":"plugins/node_id/","page":"Setting ID of nodes","title":"Setting ID of nodes","text":"model = GraphPPL.create_model(\n    GraphPPL.with_plugins(\n        mainmodel(),\n        GraphPPL.PluginsCollection(GraphPPL.NodeIdPlugin())\n    )\n)\nnothing #hide","category":"page"},{"location":"plugins/node_id/","page":"Setting ID of nodes","title":"Setting ID of nodes","text":"After, we can fetch all the nodes with a specific id using the GraphPPL.by_nodeid function.","category":"page"},{"location":"plugins/node_id/","page":"Setting ID of nodes","title":"Setting ID of nodes","text":"GraphPPL.by_nodeid","category":"page"},{"location":"plugins/node_id/#GraphPPL.by_nodeid","page":"Setting ID of nodes","title":"GraphPPL.by_nodeid","text":"by_nodeid(id)\n\nA filter predicate that can be used to find a node given its id in a model.\n\n\n\n\n\n","category":"function"},{"location":"plugins/node_id/","page":"Setting ID of nodes","title":"Setting ID of nodes","text":"labels = collect(filter(GraphPPL.by_nodeid(\"from submodel\"), model))\n@test all(label -> GraphPPL.getname(label) == Normal, labels) #hide\n@test length(labels) === 1 #hide\nforeach(labels) do label\n    println(GraphPPL.getname(label))\nend\nnothing #hide","category":"page"},{"location":"plugins/overview/#Plugin-system","page":"Overview","title":"Plugin system","text":"","category":"section"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"While GraphPPL is backend agnostic, specific inference backends might require additional functionality or data saved in nodes. To accommodate these needs, GraphPPL exposes a plugin system that allows users to extend the functionality of the package. Plugins allow the core package to remain lightweight, as well as allowing backend-specific functionality. For example, a node does not need to know by which line of code it was originally created. As an example, for debugging purposes, it might be useful to save this information in the node. GraphPPL implements a plugin that, when enabled on a model, saves this information in every node. This allows for useful debugging, while switching this functionality off when not needed saves the memory footprint of the model. ","category":"page"},{"location":"plugins/overview/#Creating-a-plugin","page":"Overview","title":"Creating a plugin","text":"","category":"section"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"A plugin is a structure that contains a set of functions that are called at specific points in the model creation process. The plugin is implemented with the GraphPPL.preprocess_plugin and GraphPPL.postprocess_plugin functions:","category":"page"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"GraphPPL.preprocess_plugin\nGraphPPL.postprocess_plugin","category":"page"},{"location":"plugins/overview/#GraphPPL.preprocess_plugin","page":"Overview","title":"GraphPPL.preprocess_plugin","text":"preprocess_plugin(plugin, model, context, label, nodedata, options)\n\nCall a plugin specific logic for a node with label and nodedata upon their creation.\n\n\n\n\n\n","category":"function"},{"location":"plugins/overview/#GraphPPL.postprocess_plugin","page":"Overview","title":"GraphPPL.postprocess_plugin","text":"postprocess_plugin(plugin, model)\n\nCalls a plugin specific logic after the model has been created. By default does nothing.\n\n\n\n\n\n","category":"function"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"Within these functions, the plugin can modify the model, add new nodes, or modify existing nodes. Also, additional data can be passed to nodes in the preprocess_plugin function.","category":"page"},{"location":"plugins/overview/#Available-plugins","page":"Overview","title":"Available plugins","text":"","category":"section"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"The following plugins are available by default in GraphPPL:","category":"page"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"GraphPPL.VariationalConstraintsPlugin: adds constraints to the model that are used in variational inference.\nGraphPPL.MetaPlugin: adds arbitrary metadata to nodes in the model.\nGraphPPL.NodeCreatedByPlugin: adds information about the line of code that created the node. \nGraphPPL.NodeIdPlugin: allows attaching an id to factor nodes for later inspection.","category":"page"},{"location":"plugins/overview/#Using-a-plugin","page":"Overview","title":"Using a plugin","text":"","category":"section"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"To use a plugin, call the with_plugins function when constructing a model:","category":"page"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"GraphPPL.with_plugins","category":"page"},{"location":"plugins/overview/#GraphPPL.with_plugins","page":"Overview","title":"GraphPPL.with_plugins","text":"with_plugins(generator::ModelGenerator, plugins::PluginsCollection)\n\nAttaches the plugins to the generator. For example:\n\nplugins = GraphPPL.PluginsCollection(GraphPPL.NodeCreatedByPlugin())\nnew_generator = GraphPPL.with_plugins(generator, plugins)\n\n\n\n\n\n","category":"function"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"The PluginsCollection is a collection of plugins that will be applied to the model. The order of plugins in the collection is important, as the preprocess_plugin and postprocess_plugin functions are called in the order of the plugins in the collection.","category":"page"},{"location":"plugins/overview/#Reference","page":"Overview","title":"Reference","text":"","category":"section"},{"location":"plugins/overview/","page":"Overview","title":"Overview","text":"GraphPPL.UnknownPluginType\nGraphPPL.plugin_type\nGraphPPL.PluginsCollection\nGraphPPL.add_plugin\nGraphPPL.VariableNodePlugin\nGraphPPL.FactorNodePlugin\nGraphPPL.FactorAndVariableNodesPlugin","category":"page"},{"location":"plugins/overview/#GraphPPL.UnknownPluginType","page":"Overview","title":"GraphPPL.UnknownPluginType","text":"A trait object for unknown plugins. Such plugins cannot be added to the collection, unless they implement the plugin_type method.\n\n\n\n\n\n","category":"type"},{"location":"plugins/overview/#GraphPPL.plugin_type","page":"Overview","title":"GraphPPL.plugin_type","text":"Checks the type of the plugin and returns the corresponding trait object.\n\n\n\n\n\n","category":"function"},{"location":"plugins/overview/#GraphPPL.PluginsCollection","page":"Overview","title":"GraphPPL.PluginsCollection","text":"A collection of plugins.\n\n\n\n\n\n","category":"type"},{"location":"plugins/overview/#GraphPPL.add_plugin","page":"Overview","title":"GraphPPL.add_plugin","text":"add_plugin(collection::PluginsCollection, plugin)\n\nAdds a plugin to the collection. The plugin must be of a type that is supported by the collection.\n\n\n\n\n\n","category":"function"},{"location":"plugins/overview/#GraphPPL.VariableNodePlugin","page":"Overview","title":"GraphPPL.VariableNodePlugin","text":"A trait object for plugins that add extra functionality for variable nodes.\n\n\n\n\n\n","category":"type"},{"location":"plugins/overview/#GraphPPL.FactorNodePlugin","page":"Overview","title":"GraphPPL.FactorNodePlugin","text":"A trait object for plugins that add extra functionality for factor nodes.\n\n\n\n\n\n","category":"type"},{"location":"plugins/overview/#GraphPPL.FactorAndVariableNodesPlugin","page":"Overview","title":"GraphPPL.FactorAndVariableNodesPlugin","text":"A trait object for plugins that add extra functionality both for factor and variable nodes.\n\n\n\n\n\n","category":"type"},{"location":"plugins/created_by/#plugins-node-created-by","page":"Tracking creation of nodes","title":"\"Created by\" plugin","text":"","category":"section"},{"location":"plugins/created_by/","page":"Tracking creation of nodes","title":"Tracking creation of nodes","text":"The @model macro is capable of saving arbitrary extra metadata information for individual factor nodes upon creation.  This feature is used by various plugins, one of which is GraphPPL.NodeCreatedByPlugin.","category":"page"},{"location":"plugins/created_by/","page":"Tracking creation of nodes","title":"Tracking creation of nodes","text":"GraphPPL.NodeCreatedByPlugin","category":"page"},{"location":"plugins/created_by/#GraphPPL.NodeCreatedByPlugin","page":"Tracking creation of nodes","title":"GraphPPL.NodeCreatedByPlugin","text":"NodeCreatedByPlugin\n\nA plugin that adds a created_by property to the factor node. This field is used to track the expression that created the node.\n\n\n\n\n\n","category":"type"},{"location":"plugins/created_by/","page":"Tracking creation of nodes","title":"Tracking creation of nodes","text":"This plugin saves the expression that has been used to create a particular factor node, which can later be queried, for example, for debugging purposes.  Here's how it works:","category":"page"},{"location":"plugins/created_by/","page":"Tracking creation of nodes","title":"Tracking creation of nodes","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function probabilistic_model()\n    x ~ Beta(1, 1)\n    for i in 1:10\n        y[i] ~ Normal(x, 1)\n    end\nend\n\nmodel = GraphPPL.create_model(\n    GraphPPL.with_plugins(\n        probabilistic_model(),\n        GraphPPL.PluginsCollection(GraphPPL.NodeCreatedByPlugin())\n    )\n)\nnothing #hide","category":"page"},{"location":"plugins/created_by/","page":"Tracking creation of nodes","title":"Tracking creation of nodes","text":"We can now read the :created_by extra field for each individual node to see the expression that has created it. To do that we need to call the GraphPPL.getextra on GraphPPL.NodeData object with the :created_by as the key.","category":"page"},{"location":"plugins/created_by/","page":"Tracking creation of nodes","title":"Tracking creation of nodes","text":"GraphPPL.factor_nodes(model) do label, nodedata\n    println(\"Node \", label, \" has been created by \", GraphPPL.getextra(nodedata, :created_by))\nend\n@test repr(GraphPPL.getextra(model[GraphPPL.getcontext(model)[Beta, 1]], :created_by)) == \"x ~ Beta(1, 1)\" #hide\n@test all(repr(GraphPPL.getextra(model[GraphPPL.getcontext(model)[Normal, i]], :created_by)) == \"y[i] ~ Normal(x, 1)\" for i in 1:10) #hide\nnothing #hide","category":"page"},{"location":"plugins/created_by/","page":"Tracking creation of nodes","title":"Tracking creation of nodes","text":"The nodes correctly identify the expressions, which have created them.","category":"page"},{"location":"nested_models/#nested-models","page":"Nested Models","title":"Nested model specification","text":"","category":"section"},{"location":"nested_models/","page":"Nested Models","title":"Nested Models","text":"GraphPPL supports nested model specification, allowing hierarchical modeling and model specification. This means that any model that is defined in GraphPPL can be used as a submodel in another model. This allows us to write models that are more modular and reusable. This page will go over the syntax for nested model specification in GraphPPL and how to use it.","category":"page"},{"location":"nested_models/#Markov-Blankets","page":"Nested Models","title":"Markov Blankets","text":"","category":"section"},{"location":"nested_models/","page":"Nested Models","title":"Nested Models","text":"In GraphPPL, a model is defined as a collection of random variables and their dependencies. This means that there are internal variables of the model, and variables that communicate with the outside of the model. These boundary variables are called the Markov Blanket of a model, and we have to specify them when we use a model as a submodel. To specify the Markov Blanket of a model, we include their names in the model function definition. For example, we can define the well-known Gaussian-with-Controlled-Variance model as follows:","category":"page"},{"location":"nested_models/","page":"Nested Models","title":"Nested Models","text":"using GraphPPL\nimport GraphPPL: @model\n\n@model function gcv(κ, ω, z, x, y)\n    log_σ := κ * z + ω\n    σ := exp(log_σ)\n    y ~ Normal(x, σ)\nend","category":"page"},{"location":"nested_models/","page":"Nested Models","title":"Nested Models","text":"Here, we see that the κ, ω, z, x and y variables define the boundary of the gcv submodel, with σ and log_σ as internal variables. ","category":"page"},{"location":"nested_models/#Invoking-submodels","page":"Nested Models","title":"Invoking submodels","text":"","category":"section"},{"location":"nested_models/","page":"Nested Models","title":"Nested Models","text":"If we want to chain these gcv submodels together into a Hierarchical Gaussian Filter, we still use the ~ operator. Here, in the arguments to gcv, we specify all-but-one interface. GraphPPL will interpolate which interface is missing and assign it to the left-hand-side:","category":"page"},{"location":"nested_models/","page":"Nested Models","title":"Nested Models","text":"@model function hgf(κ, ω, θ, prior_x, depth)\n    for i = 1:depth\n        if i == 0\n            means[i] ~ gcv(κ = κ, ω = ω, θ = θ, x = prior_x)\n        else\n            means[i] ~ gcv(κ = κ, ω = ω, θ = θ, x = means[i - 1])\n        end\n    end\nend","category":"page"},{"location":"nested_models/","page":"Nested Models","title":"Nested Models","text":"Note that in our invocations of gcv, we haven't specified the y argument of the Markov Blanket. This is what is being recognized as the missing interface and GraphPPL will assign means[i] to y.","category":"page"},{"location":"syntax_guide/#syntax-guide","page":"Syntax Guide","title":"Syntax Guide","text":"","category":"section"},{"location":"syntax_guide/#The-@model-macro","page":"Syntax Guide","title":"The @model macro","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"The @model macro accepts a description of a probabilistic program and defines a function that creates (upon materialization) a corresponding factor graph. The single argument of the macro is a Julia function. ","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function model_definition_example()\n    y ~ Beta(1.0, 1.0)\nend\nmodel_definition_example() #hide","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"The model function can accept arguments","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"@model function model_definition_example(a, b)\n    y ~ Beta(a, b)\nend\nmodel_definition_example(a = 1, b = 2) #hide","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"Note that all argument are converted to keyword arguments and positional arguments are not supported. As a consequence, the models defined with the @model macro can't use multiple dispatch.","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"model_definition_example(a = 1.0, b = 1.0)","category":"page"},{"location":"syntax_guide/#The-operator","page":"Syntax Guide","title":"The ~ operator","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"The ~ operator is at the heart of the GraphPPL syntax. It is used to define and specify the distribution of a random variable. In general, we can write x ~ dist(args...) to specify that the random variable x is distributed according to the distribution dist with parameters args.... On the left hand side of the ~ operator we have a single random variable that doesn't necessarily have to be defined yet. On the right hand side we have any factor function that takes some arguments. The arguments to the factor function should be defined, either as constants or as other random variables. The expression on the right hand side of the ~ operator can be a complex expression. For example, we can write x ~ Bernoulli(Beta(sum(ones(10)), 1)) as an overly complicated way to define a Bernoulli random variable with a Beta(10, 1) prior.","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"Variables created with the ~ operator can be used in subsequent statements. The following example reimplements our overly complicated Bernoulli random variable by explicitly defining the p parameter:","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function tilde_operator_example(x)\n    p ~ Beta(10, 1)\n    x ~ Bernoulli(p)\nend","category":"page"},{"location":"syntax_guide/#The-:-operator","page":"Syntax Guide","title":"The := operator","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"Mathematically, the ~ operator is used to define a stochastic relationship: x ~ dist(args...) means that x is distributed according to dist(args...). It is therefore mathematically incorrect to use the ~ operator to denote a deterministic relationship. For example: x ~ 1 + 1 does not make sense. However, deterministic relations are often useful in probabilistic modeling. However, the operation we want to perform is significantly different from an ordinary = assignment, since we do want to make a factor node for this deterministic relationship and include it in the factor graph. For these reasons, we introduce the := operator. The := operator is an alias to the ~ operator, that can be used in the same way as the ~ operator, but it is used to denote deterministic relationships. Note that the := operator is merely syntactic sugar and is meant to give context to readers as to which relationships are deterministic and which are stochastic. The following example demonstrates the use of the := operator:","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function colon_equal_operator_example(x)\n    p ~ Normal(0, 1)\n    x := p + p\nend","category":"page"},{"location":"syntax_guide/#Broadcasting-with-the-operator","page":"Syntax Guide","title":"Broadcasting with the ~ operator","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"The ~ operator supports broadcasting. This means that we can define multiple random variables at once. For example, we can write x .~ Normal(μ, σ) with μ and σ being vectors of random variables to define multiple random variables at once and store them in the vector x. The following example demonstrates the use of broadcasting with the ~ operator:","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function broadcasting_example()\n    local p\n    for i in 1:10\n        p[i] ~ Beta(1, 1)\n    end\n    y .~ Bernoulli(p)\nend","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"In this example, we define 10 random variables p with a Beta(1, 1) prior and then define a vector of random variables y with a Bernoulli distribution with the entries of p as parameters.","category":"page"},{"location":"syntax_guide/#Difference-between-random-variables-and-parameters","page":"Syntax Guide","title":"Difference between random variables and parameters","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"GraphPPL makes an explicit distinction between random variables and parameters, even though they can both enter the model in the same way. Random variables are explicitly present in your factor graph and are not known on model construction (This definition seems backwards since \"Random variables\" are never truly known, but in case of, for example, data entering your model, we have that we represent the data as a random variable in the factor graph, and even though we would know the value of the data during inference, we don't know the value yet during model construction). Parameters, on the other hand, are known during model construction and are not present in the factor graph. As an example, we can define the following model:","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function recursive_model(depth, y)\n    if depth == 0\n        y ~ Normal(0, 1)\n    else\n        x ~ Normal(0, 1)\n        y ~ recursive_model(depth = depth - 1)\n    end\nend","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"Here, we use depth as a parameter: It defines the control flow of the model construction, and defines the amount of recursive_model submodels we create. y is a random variable: It is present in the factor graph and is not known during model construction. Therefore, we can never use statements like if y > 0 in the model definition, since y is not known during model construction. Conversely, we cannot infer a distribution over depth, since it is a parameter and not a random variable.","category":"page"},{"location":"syntax_guide/#local-keyword","page":"Syntax Guide","title":"local keyword","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"As is customary in Julia, a for loop opens a local scope. This means that variables defined inside the for loop are not accessible outside of the loop. This can be problematic when defining random variables inside a loop. In similar fashion to Julia, we can define a variable with the local keyword and make it accessible outside of the loop, while setting priors inside the loop. The following example demonstrates the use of the local keyword:","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function local_keyword_example()\n    local p\n    for i in 1:10\n        p[i] ~ Beta(1, 1)\n    end\n    y .~ Bernoulli(p)\nend","category":"page"},{"location":"syntax_guide/#The-new-function","page":"Syntax Guide","title":"The new function","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"GraphPPL explicitly handles the ~ operator with a single random variable on the left hand side, and predefined random variables as arguments on the right hand side. However, sometimes we want to simultaneously create multiple random variables from the same submodel. One of the situations in which this occurs is in state-space models, where we want to create a datapoint as well as the state of the system at the next timestep as new random variables when invoking a time-slice of the model as a submodel. For this purpose, we introduce the new function. The new function can wrap random variables on the right hand side of the ~ operator to indicate to GraphPPL that the random variable should be created anew. The following example demonstrates the use of the new function:","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function time_slice_ssm(y, x_prev, x_new)\n    y ~ Normal(x_prev, 1)\n    x_new ~ Normal(x_prev, 1)\nend\n\n@model function ssm(y)\n    x[1] ~ Normal(0, 1)\n    for i in eachindex(y)\n        y[i] ~ time_slice_ssm(x_prev = x[i], x_new = new(x[i + 1]))\n    end\nend","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"note: Note\nThe new function is a syntax construct that can be used only within the ~ expression and does not exist in run-time. GraphPPL cannot define this function as it is a reserved keyword in Julia.","category":"page"},{"location":"syntax_guide/#The-where-{-meta-...-}-block","page":"Syntax Guide","title":"The where { meta = ... } block","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"Factor nodes can have arbitrary metadata attached to them with the where { meta = ... } block after the ~ operator.  For this functionality to work the GraphPPL.MetaPlugin must be enabled. This metadata can be queried by inference packages to modify the inference procedure. For example:","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function some_model(a, b)\n    x ~ Beta(a, b) where { meta = \"Hello, world!\" }\nend\n\nmodel = GraphPPL.create_model(\n    GraphPPL.with_plugins(\n        some_model(a = 1, b = 2),\n        GraphPPL.PluginsCollection(GraphPPL.MetaPlugin())\n    )\n)\n\nctx   = GraphPPL.getcontext(model)\nnode  = model[ctx[Beta, 1]]\n\n@test GraphPPL.getextra(node, :meta) == \"Hello, world!\" #hide\nGraphPPL.getextra(node, :meta)","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"Other plugins can hook into the where { ... } block with the GraphPPL.preprocess_plugin.","category":"page"},{"location":"syntax_guide/#Tracking-the-created_by-field","page":"Syntax Guide","title":"Tracking the created_by field","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"Factor nodes in the models can optionaly save the expressions with which they were created. For this functionality to  work the GraphPPL.NodeCreatedByPlugin plugin must be enabled. For example: ","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function some_model(a, b)\n    x ~ Beta(a, b)\n    y ~ Beta(x, 1)\nend\n\nmodel = GraphPPL.create_model(\n    GraphPPL.with_plugins(\n        some_model(a = 1, b = 2),\n        GraphPPL.PluginsCollection(GraphPPL.NodeCreatedByPlugin())\n    )\n)\nctx    = GraphPPL.getcontext(model)\nnode_1 = model[ctx[Beta, 1]]\nnode_2 = model[ctx[Beta, 2]]\n\nnothing #hide","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"@test repr(GraphPPL.getextra(node_1, :created_by)) == \"x ~ Beta(a, b)\" #hide\nGraphPPL.getextra(node_1, :created_by)","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"@test repr(GraphPPL.getextra(node_2, :created_by)) == \"y ~ Beta(x, 1)\" #hide\nGraphPPL.getextra(node_2, :created_by)","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"More information about GraphPPL.NodeCreatedByPlugin can be found here.","category":"page"},{"location":"syntax_guide/#The-return-statement","page":"Syntax Guide","title":"The return statement","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"Model can have the return statement inside of them for early stopping.  The return statement plays no role in nested models specification, however. The inference packages can also query the return statement of a specific model if needed from its GraphPPL.Context.","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function some_model(a, b)\n    x ~ Beta(a, b)\n    return \"Hello, world!\"\nend\n\nmodel = GraphPPL.create_model(some_model(a = 1, b = 2))\nctx   = GraphPPL.getcontext(model)\n@test GraphPPL.returnval(ctx) == \"Hello, world!\" #hide\nGraphPPL.returnval(ctx)","category":"page"},{"location":"syntax_guide/#Nested-models","page":"Syntax Guide","title":"Nested models","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"GraphPPL supports any previously defined model to be used as a submodel in another model. We have dedicated a separate page in the documentation on this topic, which can be found here.","category":"page"},{"location":"syntax_guide/#Scopes","page":"Syntax Guide","title":"Scopes","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"While GraphPPL aims to be as close to Julia as possible, there are some differences in the way scopes are handled. In Julia, a for loop opens a new scope, meaning that variables defined inside the loop are not accessible outside of the loop. While this is also true in GraphPPL and variables can be defined with the local keyword to make them accessible outside of the loop, creating a variable with the same name in two different for-loops will reference the same variable. This is different from Julia, where the two variables would be distinct. The following example demonstrates this behaviour:","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function scope_example()\n    for i in 1:10\n        x[i] ~ Normal(0, 1)\n    end\n    for i in 1:10\n        x[i] ~ Normal(0, 1)\n    end\nend","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"Instead of creating 20 random variables, this model will create 10 random variables and then reuse them in the second loop. This is because of the way GraphPPL handles variable creation. If you want to create 20 distinct random variables, you should use different names for the variables in the two loops.","category":"page"},{"location":"syntax_guide/#Arrays-in-GraphPPL","page":"Syntax Guide","title":"Arrays in GraphPPL","text":"","category":"section"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"As you can see in the previous examples, arrays in GraphPPL behave slightly differently than in Julia. In GraphPPL, we can define any x[i] as the left hand side of the ~ operator, without prespecifying x or its size. This trick involves a custom implementation of arrays in GraphPPL that dynamically grows as needed. This means that custom list comprehension statements in GraphPPL could give some unexpected behaviour. These examples are mostly pathological and should in general be avoided. However, if you do need custom list constructions, please wrap the result in GraphPPL.ResizableArray to ensure that factor nodes and submodels accept the array as a valid input. Note that variational constraints might throw exceptions if you try to specify a variational factorization constraint over custom created arrays of random variables.","category":"page"},{"location":"syntax_guide/","page":"Syntax Guide","title":"Syntax Guide","text":"using GraphPPL, Distributions, Test #hide\nimport GraphPPL: @model #hide\n\n@model function array_example()\n    x1 ~ Normal(0, 1)\n    x2 ~ Normal(0, 1)\n    x3 ~ Normal(0, 1)\n    x = GraphPPL.ResizableArray([x1, x2, x3])\n    y ~ some_submodel(in = x)\nend","category":"page"},{"location":"migration_3_to_4/#Migration-Guide","page":"Migration Guide (from v3 to v4)","title":"Migration Guide","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"This page describes the major changes between GraphPPL v3 and v4. The v4 introduced many changes to the language and the API. The changes are designed to make the language more consistent and easier to use, but also are tested better and provides extra features for the future releases. These changes are, however, not backward compatible with the previous versions of GraphPPL, such as v3. In this guide, we will describe the major changes between the two versions and provide examples to help you migrate your code to the new version.","category":"page"},{"location":"migration_3_to_4/#The-@model-macro","page":"Migration Guide (from v3 to v4)","title":"The @model macro","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The @model macro is no longer exported from the library and is only provided for interactive purposes (e.g. plotting).  The downstream package must define their own @model macro and use the GraphPPL.model_macro_interior function with a custom backend.","category":"page"},{"location":"migration_3_to_4/#Model-definition","page":"Migration Guide (from v3 to v4)","title":"Model definition","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"Model definition in version 4 is similar to version 3. The main difference is the deletion of the datavar, randomvar and constvar syntax. Previously the random variables and data variables needed to be specified in advance. This is no longer possible but also is unnecessary. GraphPPL is able to infer the type of the variable based on the way in which it is used. This greatly trims down the amount of code to be written in the model definition.  ","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The following example is a simple model definition in version 3:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@model function SSM(n, x0, A, B, Q, P) \n \t x = randomvar(n) \n \t y = datavar(Vector{Float64}, n) \n \t x_prior ~ MvNormal(μ = mean(x0), Σ = cov(x0)) \n \t x_prev = x_prior \n \t for i in 1:n \n \t\t   x[i] ~ MvNormal(μ = A * x_prev, Σ = Q) \n \t\t   y[i] ~ MvNormal(μ = B * x[i], Σ = P) \n \t\t   x_prev = x[i] \n \t end \n end ","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The equivalent model definition in version 4 is as follows:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":" @model function SSM(y, prior_x, A, B, Q, P) \n     x_prev ~ prior_x\n     for i in eachindex(y)\n        x[i] ~ MvNormal(μ = A * x_prev, Σ = Q) \n        y[i] ~ MvNormal(μ = B * x[i], Σ = P) \n        x_prev = x[i]\n    end\nend","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"As you can see, variable creation still requires the ~ operator. However, there are a couple of subtle changes compared to the old version of GraphPPL:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The randomvar and datavar syntax is no longer needed. GraphPPL is able to infer the type of the variable based on the way in which it is used.\nThe data y is an explicit parameter of the model function.\nThe n parameter is no longer needed. The size of the variable x is inferred from the size of the variable y.\nWe are no longer required to extract the mean and covariance of our prior distribution using the MvNormal(μ = mean(x0), Σ = cov(x0)) pattern. Instead, we can pass a prior and call x_prev ~ prior_x to assign it to an edge in the factor graph.\nThe data y is passed as an argument to the model. This is because of the support of nested models in version 4. In the Nested models we elaborate more on this design choice.","category":"page"},{"location":"migration_3_to_4/#Vectors-and-arrays","page":"Migration Guide (from v3 to v4)","title":"Vectors and arrays","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"As seen in the example above, we can assign x[i] without explicitly defining x first. GraphPPL is able to infer that x is a vector of random variables, and will grow the internal representation of x accordingly to accomodate i elements. Note that this works recursively, so z[i, j] will define a matrix of random variables. GraphPPL does check that the index [i,j] is compatible with the shape of the variable z.","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"note: Note\neachindex(y) works only if y has a static data associated with it. Read the documentation for GraphPPL.create_model for more information.","category":"page"},{"location":"migration_3_to_4/#Factor-aliases","page":"Migration Guide (from v3 to v4)","title":"Factor aliases","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"In version 4, we can define factor aliases to define different implementations of the same factor. For example, in RxInfer.jl, there are multiple implentations of the Normal distribution. Previously, we would have to explicitly call NormalMeanVariance or NormalMeanPrecision. In version 4, we can define factor aliases to default to certain implementations when specific keyword arguments are used on construction. For example: Normal(μ = 0, σ² = 1) will default to NormalMeanVariance and Normal(μ = 0, τ = 1) will default to NormalMeanPrecision. This allows users to quickly toggle between different implementations of the same factor, while keeping an implementation agnostic model definition.","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"note: Note\nThis feature works only in the combination with the ~ operator, which creates factor nodes. Therefore it cannot be used to instantiate a distribution object in a regular Julia code.","category":"page"},{"location":"migration_3_to_4/#Nested-models","page":"Migration Guide (from v3 to v4)","title":"Nested models","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The major difference between versions 3 and 4 is the support for nested models. In version 4, models can be nested within each other. This allows for more complex models to be built in a modular way. The following example demonstrates how to nest models in version 4:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@model function kalman_filter_step(y, prev_x, new_x, A, B, Q, P)\n    new_x ~ MvNormal(μ = A * prev_x, Σ = Q)\n    y ~ MvNormal(μ = B * new_x, Σ = P)\nend\n\n@model function state_space_model(y, A, B, Q, P)\n    x[1] ~ MvNormal(zeros(2), diagm(ones(2)))\n    for i in eachindex(y)\n        y[i] ~ kalman_filter_step(prev_x = x[i], new_x = new(x[i + 1]), A=A, B=B, Q=Q, P=P)\n    end\nend","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"Note that we reuse the kalman_filter_step model in the state_space_model model. In the argument list of any GraphPPL model, we have to specify the Markov Blanket of the model we are defining. This means that all interfaces with the outside world have to be passed as arguments to the model. For the kalman_filter_step model, we pass the previous state prev_x, the new state new_x, the observation y as well as the parameters A, B, Q and P. This means that, when invoking a submodel in a larger model, we can specify all components of the Markov Blanket. Note that, in the state_space_model model, we do not pass y as an argument to the kalman_filter_step model. GraphPPL will infer that y is missing from the argument list and assign it to whatever is left of the ~ operator. Note that we also use the new(x[i + 1]) syntax to create a new variable in the position of x[i + 1]. Since y is also passed in the argument list of the state_space_model model, we could have written this line with the equivalen statement x[i + 1] ~ kalman_filter_step(prev_x = x[i], y = y[i], A=A, B=B, Q=Q, P=P). However, to respect the generative direction of the model and to make the code more readable, we use the new(x[i + 1]) syntax. Note, however, that the underlaying representation of the models in GraphPPL are still undirected.","category":"page"},{"location":"migration_3_to_4/#Constraint-specification","page":"Migration Guide (from v3 to v4)","title":"Constraint specification","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"With the introduction of nested models, the specification of variational constraints becomes more difficult. In version 3, variable names were uniquely defined in the model, which made it easy to specify constraints on variables. In version 4, nested models can contain variables with the same name as their parents, even though they are distinct random variables. Therefore, we need to specify constraints on submodel level in the constraints macro. This is done with the for q in _submodel_ syntax. ","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"For example:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@constraints begin\n    for q in kalman_filter_step\n        q(new_x, prev_x, y) = q(new_x, prev_x)q(y)\n    end\nend","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"This specification reuses the same constraint to all instances of the kalman_filter_step submodel. Of course, we'd like to have more flexibility in the constraints we can specify. Therefore, we can also specify constraints on a specific instance of the submodel. For example:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@constraints begin\n    for q in (kalman_filter_step, 1)\n        q(new_x, prev_x, y) = q(new_x, prev_x)q(y)\n        q(new_x) :: Normal\n    end\nend","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"This pushes the constraint to the first instance of the kalman_filter_step submodel. With this syntax, we can specify constraints on any instance of a submodel. ","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The function syntax for constraints is still supported. For example:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@constraints function ssm_constraints(factorize)\n    for q in kalman_filter_step\n        if factorize\n            q(new_x, prev_x, y) = MeanField()\n        else\n            q(new_x, prev_x, y) = q(new_x, prev_x)q(y)\n        end\n    end\nend","category":"page"},{"location":"migration_3_to_4/#Meta-specification","page":"Migration Guide (from v3 to v4)","title":"Meta specification","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The meta specification follows exactly the same structure as the constraints specification. Nested models in the @meta macro are specified in the same way as in the @constraints macro. ","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"For example:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@meta begin\n    for meta in some_submodel\n        GCV(x, k, w) -> GCVMetadata(GaussHermiteCubature(20))\n    end\n    y -> SomeMetaData()\nend","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"Additionally, we can pass arbitrary metadata to the inference backend. For example:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@meta begin\n    GCV(x, k, w) -> GCVMetadata(GaussHermiteCubature(20))\n    x -> (prod_constraint = SomeProdConstraint(), )\nend","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"By passing a NamedTuple in the @model macro, we can pass arbitrary metadata to the inference backend that we would previously have to specify in the where clause of a node. With the added functionality of the @meta macro, we can pass metadata to the inference backend in a more structured way, and detach metadata definition from model definition.","category":"page"},{"location":"migration_3_to_4/#Dispatch","page":"Migration Guide (from v3 to v4)","title":"Dispatch","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"In the new version of GraphPPL.jl it is no longer possible to use Julia's multiple dispatch within the @model function definition.  The workaround is to use nested models instead, e.g. users can pass submodels as an extra argument, therefore change the structure of the model based on the input arguments. ","category":"page"},{"location":"migration_3_to_4/#Positional-arguments","page":"Migration Guide (from v3 to v4)","title":"Positional arguments","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"In the new version of GraphPPL.jl positional arguments within model construction is no longer supported and all arguments must be named explicitly. For example:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@model function beta_bernoulli(y, a, b)\n    t ~ Beta(a, b)\n    for i in eachindex(y)\n        y[i] ~ Bernoulli(t)\n    end\nend","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"model = beta_bernoulli(1.0, 2.0) # ambigous and unsupported","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"model = beta_bernoulli(a = 1.0, b = 2.0) # explicitly defined via keyword arguments","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The same recipe applies when nesting models within each other, e.g.","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@model function bigger_model(y)\n    a ~ Uniform(0.0, 10.0)\n    b ~ Uniform(0.0, 10.0)\n    y ~ beta_bernoulli(a = a, b = b)\nend","category":"page"},{"location":"migration_3_to_4/#Mixture-Nodes","page":"Migration Guide (from v3 to v4)","title":"Mixture Nodes","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The interface of the mixture nodes does no longer require a tuple of inputs. Instead, the inputs can be passed as a vector as well. For example:","category":"page"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"@model function mixture_model(y)\n    # specify two models\n    m_1 ~ Beta(2.0, 7.0)\n    m_2 ~ Beta(7.0, 2.0)\n\n    # specify prior on switch param\n    s ~ Bernoulli(0.7) \n\n    # specify mixture prior Distribution\n    θ ~ Mixture(switch = s, inputs = [m_1, m_2])\nend","category":"page"},{"location":"migration_3_to_4/#Overview-of-the-removed-functionality","page":"Migration Guide (from v3 to v4)","title":"Overview of the removed functionality","text":"","category":"section"},{"location":"migration_3_to_4/","page":"Migration Guide (from v3 to v4)","title":"Migration Guide (from v3 to v4)","text":"The datavar, randomvar and constvar syntax is removed. GraphPPL is able to infer the type of the variable based on the way in which it is used.\nSpecifying factorization constraints in the where clause of a node is no longer possible. The where syntax can still be used to specify metadata for factor nodes, but factorization constraints can only be specified with the @constraints macro.\nDispatch in the @model macro is not supported.\nPositional arguments in the @model macro are not supporeted.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"On this page we will cover the basic syntax of GraphPPL and will work towards a basic coin-toss example. ","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"GraphPPL.jl is a registered Julia package. To install it, run the following command in the Julia REPL:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg\njulia> Pkg.add(\"GraphPPL\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide assumes you have GraphPPL.jl installed, as well as Distributions.jl to work with standard probability distributions as building blocks in our probabilistic programs.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using GraphPPL\nusing Distributions","category":"page"},{"location":"getting_started/#Creating-a-model","page":"Getting Started","title":"Creating a model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In GraphPPL, we can specify a model with the @model macro. The @model macro takes a function as an argument, and registers the blueprint of creating this model. The model macro is not exported by default by GraphPPL to allow inference packages to define their own @model macro on top of the GraphPPL.jl. For demonstration purposes we will import GraphPPL.@model explicitly:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"import GraphPPL: @model","category":"page"},{"location":"getting_started/#Syntax","page":"Getting Started","title":"Syntax","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In general, we can write probabilistic programs in GraphPPL using the ~ operator.  The x ~ X expression can be read as x sampled from X. For example, if we want to define a random variable x that is distributed according to a normal distribution with mean 0 and variance 1, we can write:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@model function example()\n    x ~ Normal(0, 1)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can also define multiple random variables in the same model:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@model function example()\n    x ~ Normal(0, 1)\n    y ~ Normal(0, 1)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"or use our newly defined random variables as parameters for other distributions:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@model function example()\n    x ~ Normal(0, 1)\n    y ~ Normal(x, 1)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can also use the := operator to define deterministic relations:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@model function example()\n    x ~ Normal(0, 1)\n    y ~ Normal(x, 1)\n    z := x + y\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that a deterministic function, when called with known parameters, will not materialize in the factor graph, but will instead compile out and return the result. To illustrate this: ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@model function example()\n    μ := 1 + 2\n    x ~ Normal(μ, 1)\n    y ~ Normal(x, 1)\n    z := x + y\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In the above example, the μ := 1 + 2 line will not materialize in the factor graph, and instead will instantiate the variable μ with the value 3. However, since x and y are random variables, the + operator will materialize in the factor graph.","category":"page"},{"location":"getting_started/#Inputs-and-interfaces","page":"Getting Started","title":"Inputs and interfaces","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In GraphPPL, we can feed data and interfaces into the model through the function arguments. For example, if we want to define a model that takes in a vector of observations x that are all distributed according to a normal distribution with mean 0 and variance 1, we can write:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@model function example(x)\n    for i in eachindex(x)\n        x[i] ~ Normal(0, 1)\n    end\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Alternatively, we can use the broadcasting syntax from Julia, extended to work with the ~ operator:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@model function example(x)\n    x .~ Normal(0, 1)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that interfaces do not need to be random variables; this distinction will be made during model construction. Until a variable is used as an input to a stochastic node, it will be treated as a regular variable. This allows us to write models that take in both data and parameters:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@model function recursive_model(x, depth)\n    if depth == 0\n        x ~ Normal(0, 1)\n    else\n        x ~ recursive_model(depth = depth - 1)\n    end\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here, x is treated as a random variable since it is connected to a Normal node. However, depth is only used as a hyperparameter to define model structure and is not connected to any stochastic nodes, so it is treated as a regular variable. In this recursive model we also get to see nested models in action: the recursive_model is used as a submodel of itself. More on this in the Nested Models section.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nModels defined with the @model macro have no positional arguments. All the arguments are converted to the keyword arguments. This also means that the models cannot use multiple dispatch, since multiple dispatch on keyword arguments is not supported in Julia.","category":"page"},{"location":"getting_started/#Bayesian-Coin-Toss-(Beta-Bernoulli-model)","page":"Getting Started","title":"Bayesian Coin-Toss (Beta-Bernoulli model)","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now that we have a grasp on the basic syntax and semantics of GraphPPL, let's try to write a simple coin-toss model a.k.a Beta-Bernoulli model. We will start with a model that takes in a series of observations x that are i.i.d. distributed according to a Bernoulli distribution with parameter θ, where we put a Beta prior on θ:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@model function coin_toss(x)\n    θ ~ Beta(1, 1)\n    x .~ Bernoulli(θ)\nend","category":"page"},{"location":"getting_started/#Instantiating-the-model","page":"Getting Started","title":"Instantiating the model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To instantiate the model we need to pass the data x. We can do that with the GraphPPL.create_model function in combination with GraphPPL.datalabel.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"data_for_x = [ 1.0, 0.0, 0.0, 1.0 ]\n\nmodel = GraphPPL.create_model(coin_toss()) do model, context\n    return (; \n        # This expression creates data handle for `x` in the model using the `xdata` as the underlying collection\n        x = GraphPPL.datalabel(model, context, GraphPPL.NodeCreationOptions(kind = GraphPPL.VariableKindData), :x, data_for_x)\n    )\nend\nnothing #hide","category":"page"},{"location":"getting_started/#Visualizing-the-model","page":"Getting Started","title":"Visualizing the model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"GraphPPL exports a simple visualization function that can be used to visualize the factor graph of a model. This requires the GraphPlot and Cairo packages to be installed. To visualize the coin_toss model, we can run:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using GraphPlot, Cairo\nGraphPlot.gplot(model)","category":"page"},{"location":"getting_started/#Syntax-Guide","page":"Getting Started","title":"Syntax Guide","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To dive into the specifics of the syntax of the model specification within GraphPPL.jl read the Syntax Guide.","category":"page"},{"location":"custom_backend/#custom-backend","page":"Custom backend","title":"Customizing the behaviour of the @model with a custom backend","text":"","category":"section"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"When creating the graphical model, GraphPPL package uses several functions to decide what to do in specific situations, for example","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"Is x ~ SomeType(y, z) a stochastic or deterministic relationship? For example SomeType can be a Gaussian, in which case the answer","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"is obvious, but what is SomeType is a Matrix? Or what if a user specified const Matrix = Gaussian?","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"Should x ~ Normal(a, b) be interpreted as x ~ Normal(mean = a, variance = b) or Normal(mean = a, standard_deviation = b)?\nShould x_next ~ HierarchicalGaussianFilter(x_prev, tau) create an Atomic or a Composite node for HierarchicalGaussianFilter? \nShould x := x1 + x2 + x3 + x4 be replaced with x := sum(x1, x2, x3, x4) or x := sum(sum(sum(x1, x2), x3), x4). Or left untouched?\nWhat extra syntax transformations are allowed? For example should not_x ~ ¬x be interpreted as a boolean random variable x with the ¬ as a stochastic node","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"or it is just a function call?","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"It is not possible to resolve these issues on a syntax level, thus GraphPPL requires a specific backend to resolve this information at run-time. ","category":"page"},{"location":"custom_backend/#Default-backend","page":"Custom backend","title":"Default backend","text":"","category":"section"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"For interactive purposes (plotting or testing) GraphPPL implements a DefaultBackend, which properly handles objects from Distributions.jl. The @model macro by itself is not exported by default. To use it explicitly simply call:","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"import GraphPPL: @model","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"GraphPPL.DefaultBackend","category":"page"},{"location":"custom_backend/#GraphPPL.DefaultBackend","page":"Custom backend","title":"GraphPPL.DefaultBackend","text":"DefaultBackend\n\nA default backend that is used in the GraphPPL.@model macro when no backend is specified explicitly.\n\n\n\n\n\n","category":"type"},{"location":"custom_backend/#Recommended-way-of-using-GraphPPL-from-a-backend-specific-inference-package","page":"Custom backend","title":"Recommended way of using GraphPPL from a backend-specific inference package","text":"","category":"section"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"A backend-specific inference package should implement its own backend structure together with its own @model macro (or a different name) that would call the @model macro from GraphPPL with a specific package. Below is the list of backend-specific functions, each of which should be implemented  in order for backend to be fully specified. ","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"GraphPPL.model_macro_interior_pipelines\nGraphPPL.NodeBehaviour\nGraphPPL.NodeType\nGraphPPL.aliases\nGraphPPL.interfaces\nGraphPPL.factor_alias\nGraphPPL.interface_aliases\nGraphPPL.default_parametrization\nGraphPPL.instantiate","category":"page"},{"location":"custom_backend/#GraphPPL.model_macro_interior_pipelines","page":"Custom backend","title":"GraphPPL.model_macro_interior_pipelines","text":"model_macro_interior_pipelines(backend)\n\nReturns a collection of syntax transformation functions for the apply_pipeline function based on a specific backend. The functions are being applied to the model in the model_macro_interior macro body in the exact same order they are returned.\n\n\n\n\n\n","category":"function"},{"location":"custom_backend/#GraphPPL.NodeBehaviour","page":"Custom backend","title":"GraphPPL.NodeBehaviour","text":"NodeBehaviour\n\nAbstract type representing either Deterministic or Stochastic for a given object. By default is Deterministic unless specified otherwise.\n\n\n\n\n\n","category":"type"},{"location":"custom_backend/#GraphPPL.NodeType","page":"Custom backend","title":"GraphPPL.NodeType","text":"NodeType\n\nAbstract type representing either Composite or Atomic trait for a given object. By default is Atomic unless specified otherwise.\n\n\n\n\n\n","category":"type"},{"location":"custom_backend/#GraphPPL.aliases","page":"Custom backend","title":"GraphPPL.aliases","text":"aliases(backend, fform)\n\nReturns a collection of aliases for fform depending on the backend.\n\n\n\n\n\n","category":"function"},{"location":"custom_backend/#GraphPPL.interfaces","page":"Custom backend","title":"GraphPPL.interfaces","text":"interfaces(backend, fform, ::StaticInt{N}) where N\n\nReturns the interfaces for a given fform and backend with a given amount of interfaces N.\n\n\n\n\n\n","category":"function"},{"location":"custom_backend/#GraphPPL.factor_alias","page":"Custom backend","title":"GraphPPL.factor_alias","text":"factor_alias(backend, fform, interfaces)\n\nReturns the alias for a given fform and interfaces with a given backend.\n\n\n\n\n\n","category":"function"},{"location":"custom_backend/#GraphPPL.interface_aliases","page":"Custom backend","title":"GraphPPL.interface_aliases","text":"interface_aliases(backend, fform)\n\nReturns the aliases for a given fform and backend.\n\n\n\n\n\n","category":"function"},{"location":"custom_backend/#GraphPPL.default_parametrization","page":"Custom backend","title":"GraphPPL.default_parametrization","text":"default_parametrization(backend, fform, rhs)\n\nReturns the default parametrization for a given fform and backend with a given rhs.\n\n\n\n\n\n","category":"function"},{"location":"custom_backend/#GraphPPL.instantiate","page":"Custom backend","title":"GraphPPL.instantiate","text":"instantiate(::Type{Backend})\n\nInstantiates a default backend object of the specified type. Should be implemented for all backends.\n\n\n\n\n\n","category":"function"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"note: Note\nThe GraphPPL.model_macro_interior automatically creates a method for GraphPPL.default_backend.","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"GraphPPL.default_backend","category":"page"},{"location":"custom_backend/#GraphPPL.default_backend","page":"Custom backend","title":"GraphPPL.default_backend","text":"default_backend(model_function)\n\nReturns a default backend for the given model function.\n\n\n\n\n\n","category":"function"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"For inference backends, we recommend to implement the @model macro using the following pattern:","category":"page"},{"location":"custom_backend/","page":"Custom backend","title":"Custom backend","text":"GraphPPL.@model\nGraphPPL.model_macro_interior","category":"page"},{"location":"custom_backend/#GraphPPL.@model","page":"Custom backend","title":"GraphPPL.@model","text":"@model function model_name(model_arguments)\n    ...\nend\n\nNote that the @model macro is not exported by default and the recommended way of using it is  in the combination with some inference backend. The GraphPPL package provides the DefaultGraphPPLBackend structure  for plotting and test purposes, but some backends may specify different behaviour for different structures. For example, the interface names of a node Normal or its behaviour may (and should) depend on the specified backend. \n\nThe recommended way of using the GraphPPL.@model macro from other backend-based packages is to define their own  @model macro, which will call the GraphPPL.model_macro_interior function with the specified backend. For example \n\nmodule SamplingBasedInference\n\nstruct SamplingBasedBackend end\n\nmacro model(model_specification)\n    return esc(GraphPPL.model_macro_interior(SamplingBasedBackend(), model_specification))\nend\n\nend\n\nRead more about the backend inteface in the corresponding section of the documentation.\n\nTo use GraphPPL package as a standalone package for plotting and testing, use the import GraphPPL: @model explicitly to add  the @model macro to the current scope. \n\n\n\n\n\n","category":"macro"},{"location":"custom_backend/#GraphPPL.model_macro_interior","page":"Custom backend","title":"GraphPPL.model_macro_interior","text":"model_macro_interior(backend, model_specification)\n\nThe function that translates the model_specification code into a Julia compatible code block given some backend.  This function must be used within the @model macro.\n\n\n\n\n\n","category":"function"},{"location":"#GraphPPL.jl-Documentation","page":"Home","title":"GraphPPL.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation of GraphPPL.jl, a Probabilistic Programming Language for Julia for specifying probabilistic models in a form of a factor graph. GraphPPL is a high-level backend-agnostic PPL that supports nested graphical models, allowing hierarchical modeling and model specification. GraphPPL materializes your probabilistic models as a factor graph. Additionally, it support a plugin system, that allows specification of inference specific information for different methods, e.g. variational inference. GraphPPL is designed to be a flexible and extensible PPL, and supports user-defined nodes and transformations. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is important to note that GraphPPL.jl is not an inference package and does not run inference in the specified models. For inference, you may need a GraphPPL.jl compatible package, for example RxInfer.jl.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"getting_started.md\",\n  \"nested_models.md\",\n  \"constraint_specification.md\",\n  \"plugins.md\",\n  \"migration.md\",\n  \"developers_guide.md\",\n  \"custom_backend.md\",\n  \"reference.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"plugins/meta_specification/#meta-specification","page":"Attaching metadata to nodes","title":"Meta Specification","text":"","category":"section"},{"location":"plugins/meta_specification/","page":"Attaching metadata to nodes","title":"Attaching metadata to nodes","text":"GraphPPL.MetaPlugin","category":"page"},{"location":"plugins/meta_specification/#GraphPPL.MetaPlugin","page":"Attaching metadata to nodes","title":"GraphPPL.MetaPlugin","text":"MetaPlugin(meta)\n\nA plugin that adds a meta information to the factor nodes of the model.\n\n\n\n\n\n","category":"type"}]
}
